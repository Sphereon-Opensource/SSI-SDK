{
  "ICredentialHandlerLDLocal": {
    "components": {
      "schemas": {
        "ICreateVerifiableCredentialLDArgs": {
          "type": "object",
          "properties": {
            "credential": {
              "$ref": "#/components/schemas/CredentialPayload",
              "description": "The json payload of the Credential according to the  {@link https://www.w3.org/TR/vc-data-model/#credentials | canonical model } \n\nThe signer of the Credential is chosen based on the `issuer.id` property of the `credential`\n\n'@context', 'type' and 'issuanceDate' will be added automatically if omitted"
            },
            "keyRef": {
              "type": "string",
              "description": "Optional. The key handle ( {@link  IKey#kid  } ) from the internal database."
            },
            "purpose": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IAuthenticationProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IControllerProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IAssertionProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IProofPurpose"
                }
              ],
              "description": "Use this purpose for the verification method in the DID when doing a check (defaults to CredentialIssuancePurpose)"
            },
            "credentialStatusOpts": {
              "$ref": "#/components/schemas/IIssueCredentialStatusOpts"
            }
          },
          "required": ["credential"],
          "description": "Encapsulates the parameters required to create a  {@link https://www.w3.org/TR/vc-data-model/#credentials | W3C Verifiable Credential }"
        },
        "CredentialPayload": {
          "type": "object",
          "properties": {
            "issuer": {
              "$ref": "#/components/schemas/IssuerType"
            },
            "credentialSubject": {
              "$ref": "#/components/schemas/CredentialSubject"
            },
            "type": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "@context": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "issuanceDate": {
              "$ref": "#/components/schemas/DateType"
            },
            "expirationDate": {
              "$ref": "#/components/schemas/DateType"
            },
            "credentialStatus": {
              "$ref": "#/components/schemas/CredentialStatusReference"
            },
            "id": {
              "type": "string"
            }
          },
          "required": ["issuer"],
          "description": "Used as input when creating Verifiable Credentials"
        },
        "IssuerType": {
          "anyOf": [
            {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string"
                }
              },
              "required": ["id"]
            },
            {
              "type": "string"
            }
          ],
          "description": "The issuer of a  {@link  VerifiableCredential }  or the holder of a  {@link  VerifiablePresentation } .\n\nThe value of the issuer property MUST be either a URI or an object containing an id property. It is RECOMMENDED that the URI in the issuer or its id be one which, if de-referenced, results in a document containing machine-readable information about the issuer that can be used to verify the information expressed in the credential.\n\nSee  {@link https://www.w3.org/TR/vc-data-model/#issuer | Issuer data model }"
        },
        "CredentialSubject": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            }
          },
          "description": "The value of the credentialSubject property is defined as a set of objects that contain one or more properties that are each related to a subject of the verifiable credential. Each object MAY contain an id.\n\nSee  {@link https://www.w3.org/TR/vc-data-model/#credential-subject | Credential Subject }"
        },
        "DateType": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "string",
              "format": "date-time"
            }
          ],
          "description": "Represents an issuance or expiration date for Credentials / Presentations. This is used as input when creating them."
        },
        "CredentialStatusReference": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            },
            "type": {
              "type": "string"
            }
          },
          "required": ["id", "type"],
          "description": "Used for the discovery of information about the current status of a verifiable credential, such as whether it is suspended or revoked. The precise contents of the credential status information is determined by the specific `credentialStatus` type definition, and varies depending on factors such as whether it is simple to implement or if it is privacy-enhancing.\n\nSee  {@link https://www.w3.org/TR/vc-data-model/#status | Credential Status }"
        },
        "IAuthenticationProofPurpose": {
          "type": "object",
          "properties": {
            "term": {
              "type": "string"
            },
            "date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "number"
                }
              ]
            },
            "maxTimestampDelta": {
              "type": "number"
            },
            "controller": {
              "type": "object"
            },
            "challenge": {
              "type": "string"
            },
            "domain": {
              "type": "string"
            }
          }
        },
        "IControllerProofPurpose": {
          "type": "object",
          "properties": {
            "term": {
              "type": "string"
            },
            "date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "number"
                }
              ]
            },
            "maxTimestampDelta": {
              "type": "number"
            },
            "controller": {
              "type": "object"
            }
          }
        },
        "IAssertionProofPurpose": {
          "type": "object",
          "properties": {
            "term": {
              "type": "string"
            },
            "date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "number"
                }
              ]
            },
            "maxTimestampDelta": {
              "type": "number"
            },
            "controller": {
              "type": "object"
            }
          }
        },
        "IProofPurpose": {
          "type": "string",
          "enum": [
            "verificationMethod",
            "assertionMethod",
            "authentication",
            "keyAgreement",
            "contactAgreement",
            "capabilityInvocation",
            "capabilityDelegation"
          ]
        },
        "IIssueCredentialStatusOpts": {
          "type": "object",
          "properties": {
            "dataSource": {
              "$ref": "#/components/schemas/DataSource"
            },
            "statusLists": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/StatusListOpts"
              }
            },
            "credentialId": {
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          }
        },
        "DataSource": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "name": {
              "type": "string",
              "description": "Connection name.",
              "deprecated": "we don't need names anymore since we are going to drop all related methods relying on this property."
            },
            "options": {
              "$ref": "#/components/schemas/DataSourceOptions",
              "description": "Connection options."
            },
            "isInitialized": {
              "type": "boolean",
              "description": "Indicates if DataSource is initialized or not."
            },
            "driver": {
              "$ref": "#/components/schemas/Driver",
              "description": "Database driver used by this connection."
            },
            "manager": {
              "$ref": "#/components/schemas/EntityManager",
              "description": "EntityManager of this connection."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy used in the connection."
            },
            "metadataTableName": {
              "type": "string",
              "description": "Name for the metadata table"
            },
            "logger": {
              "$ref": "#/components/schemas/Logger",
              "description": "Logger used to log orm events."
            },
            "migrations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/MigrationInterface"
              },
              "description": "Migration instances that are registered for this connection."
            },
            "subscribers": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntitySubscriberInterface<any>"
              },
              "description": "Entity subscriber instances that are registered for this connection."
            },
            "entityMetadatas": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityMetadata"
              },
              "description": "All entity metadatas that are registered for this connection."
            },
            "entityMetadatasMap": {
              "type": "object",
              "properties": {
                "size": {
                  "type": "number"
                }
              },
              "required": ["size"],
              "description": "All entity metadatas that are registered for this connection. This is a copy of #.entityMetadatas property -> used for more performant searches."
            },
            "queryResultCache": {
              "$ref": "#/components/schemas/QueryResultCache",
              "description": "Used to work with query result cache."
            },
            "relationLoader": {
              "$ref": "#/components/schemas/RelationLoader",
              "description": "Used to load relations and work with lazy relations."
            },
            "relationIdLoader": {
              "$ref": "#/components/schemas/RelationIdLoader"
            }
          },
          "required": [
            "@instanceof",
            "name",
            "options",
            "isInitialized",
            "driver",
            "manager",
            "namingStrategy",
            "metadataTableName",
            "logger",
            "migrations",
            "subscribers",
            "entityMetadatas",
            "entityMetadatasMap",
            "relationLoader",
            "relationIdLoader"
          ],
          "description": "DataSource is a pre-defined connection configuration to a specific database. You can have multiple data sources connected (with multiple connections in it), connected to multiple databases in your application.\n\nBefore, it was called `Connection`, but now `Connection` is deprecated because `Connection` isn't the best name for what it's actually is."
        },
        "DataSourceOptions": {
          "anyOf": [
            {
              "$ref": "#/components/schemas/MysqlConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/PostgresConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/CockroachConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/SqliteConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/SqlServerConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/SapConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/OracleConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/CordovaConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/NativescriptConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/ReactNativeConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/SqljsConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/MongoConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/AuroraMysqlConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/AuroraPostgresConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/ExpoConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/BetterSqlite3ConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/CapacitorConnectionOptions"
            },
            {
              "$ref": "#/components/schemas/SpannerConnectionOptions"
            }
          ],
          "description": "DataSourceOptions is an interface with settings and options for specific DataSource."
        },
        "MysqlConnectionOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "ssl": {
              "description": "Object with ssl parameters or a string containing name of ssl profile."
            },
            "socketPath": {
              "type": "string",
              "description": "Database socket path"
            },
            "type": {
              "type": "string",
              "enum": ["mysql", "mariadb"],
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "type": "number",
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "driver": {
              "description": "The driver object This defaults to require(\"mysql\"). Falls back to require(\"mysql2\")"
            },
            "charset": {
              "type": "string",
              "description": "The charset for the connection. This is called \"collation\" in the SQL-level of MySQL (like utf8_general_ci). If a SQL-level charset is specified (like utf8mb4) then the default collation for that charset is used. Default: 'UTF8_GENERAL_CI'"
            },
            "timezone": {
              "type": "string",
              "description": "The timezone configured on the MySQL server. This is used to type cast server date/time values to JavaScript Date object and vice versa. This can be 'local', 'Z', or an offset in the form +HH:MM or -HH:MM. (Default: 'local')"
            },
            "connectTimeout": {
              "type": "number",
              "description": "The milliseconds before a timeout occurs during the initial connection to the MySQL server. (Default: 10000)"
            },
            "acquireTimeout": {
              "type": "number",
              "description": "The milliseconds before a timeout occurs during the initial connection to the MySQL server. (Default: 10000) This difference between connectTimeout and acquireTimeout is subtle and is described in the mysqljs/mysql docs https://github.com/mysqljs/mysql/tree/master#pool-options"
            },
            "insecureAuth": {
              "type": "boolean",
              "description": "Allow connecting to MySQL instances that ask for the old (insecure) authentication method. (Default: false)"
            },
            "supportBigNumbers": {
              "type": "boolean",
              "description": "When dealing with big numbers (BIGINT and DECIMAL columns) in the database, you should enable this option (Default: false)"
            },
            "bigNumberStrings": {
              "type": "boolean",
              "description": "Enabling both supportBigNumbers and bigNumberStrings forces big numbers (BIGINT and DECIMAL columns) to be always returned as JavaScript String objects (Default: false). Enabling supportBigNumbers but leaving bigNumberStrings disabled will return big numbers as String objects only when they cannot be accurately represented with [JavaScript Number objects](http://ecma262-5.com/ELS5_HTML.htm#Section_8.5) (which happens when they exceed the [-2^53, +2^53] range), otherwise they will be returned as Number objects. This option is ignored if supportBigNumbers is disabled."
            },
            "dateStrings": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Force date types (TIMESTAMP, DATETIME, DATE) to be returned as strings rather then inflated into JavaScript Date objects. Can be true/false or an array of type names to keep as strings."
            },
            "debug": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Prints protocol details to stdout. Can be true/false or an array of packet type names that should be printed. (Default: false)"
            },
            "trace": {
              "type": "boolean",
              "description": "Generates stack traces on Error to include call site of library entrance (\"long stack traces\"). Slight performance penalty for most calls. (Default: true)"
            },
            "multipleStatements": {
              "type": "boolean",
              "description": "Allow multiple mysql statements per query. Be careful with this, it could increase the scope of SQL injection attacks. (Default: false)"
            },
            "legacySpatialSupport": {
              "type": "boolean",
              "description": "Use spatial functions like GeomFromText and AsText which are removed in MySQL 8. (Default: true)"
            },
            "flags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of connection flags to use other than the default ones. It is also possible to blacklist default ones. For more information, check https://github.com/mysqljs/mysql#connection-flags."
            },
            "connectorPackage": {
              "type": "string",
              "enum": ["mysql", "mysql2"],
              "description": "TypeORM will automatically use package found in your node_modules, prioritizing mysql over mysql2, but you can specify it manually"
            },
            "replication": {
              "type": "object",
              "properties": {
                "master": {
                  "$ref": "#/components/schemas/MysqlConnectionCredentialsOptions",
                  "description": "Master server used by orm to perform writes."
                },
                "slaves": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MysqlConnectionCredentialsOptions"
                  },
                  "description": "List of read-from servers (slaves)."
                },
                "canRetry": {
                  "type": "boolean",
                  "description": "If true, PoolCluster will attempt to reconnect when connection fails. (Default: true)"
                },
                "removeNodeErrorCount": {
                  "type": "number",
                  "description": "If connection fails, node's errorCount increases. When errorCount is greater than removeNodeErrorCount, remove a node in the PoolCluster. (Default: 5)"
                },
                "restoreNodeTimeout": {
                  "type": "number",
                  "description": "If connection fails, specifies the number of milliseconds before another connection attempt will be made. If set to 0, then node will be removed instead and never re-used. (Default: 0)"
                },
                "selector": {
                  "type": "string",
                  "enum": ["RR", "RANDOM", "ORDER"],
                  "description": "Determines how slaves are selected: RR: Select one alternately (Round-Robin). RANDOM: Select the node by random function. ORDER: Select the first node available unconditionally."
                },
                "defaultMode": {
                  "$ref": "#/components/schemas/ReplicationMode",
                  "description": "Default connection pool to use for SELECT queries",
                  "default": "slave"
                }
              },
              "required": ["master", "slaves"],
              "description": "Replication setup."
            }
          },
          "required": ["type"],
          "description": "MySQL specific connection options."
        },
        "MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>": {
          "anyOf": [
            {
              "type": "array",
              "items": {
                "anyOf": [
                  {
                    "type": "object",
                    "properties": {
                      "prototype": {},
                      "length": {
                        "type": "number"
                      },
                      "arguments": {},
                      "caller": {
                        "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                      }
                    },
                    "required": ["prototype", "length", "arguments", "caller"]
                  },
                  {
                    "type": "string"
                  },
                  {
                    "$ref": "#/components/schemas/EntitySchema"
                  }
                ]
              }
            },
            {
              "type": "object",
              "additionalProperties": {
                "anyOf": [
                  {
                    "type": "object",
                    "properties": {
                      "prototype": {},
                      "length": {
                        "type": "number"
                      },
                      "arguments": {},
                      "caller": {
                        "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                      }
                    },
                    "required": ["prototype", "length", "arguments", "caller"]
                  },
                  {
                    "type": "string"
                  },
                  {
                    "$ref": "#/components/schemas/EntitySchema"
                  }
                ]
              }
            }
          ],
          "description": "List of T-s passed as an array or object map.\n\nExample usage: entities as an array of imported using import * as syntax."
        },
        "interface-1506616821-9888-11315-1506616821-0-215038": {
          "type": "object",
          "properties": {
            "prototype": {},
            "length": {
              "type": "number"
            },
            "arguments": {},
            "caller": {
              "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
            }
          },
          "required": ["prototype", "length", "arguments", "caller"]
        },
        "EntitySchema": {
          "type": "object",
          "properties": {
            "options": {
              "$ref": "#/components/schemas/EntitySchemaOptions<any>"
            },
            "@instanceof": {}
          },
          "required": ["options", "@instanceof"],
          "description": "Interface for entity metadata mappings stored inside \"schemas\" instead of models decorated by decorators."
        },
        "EntitySchemaOptions<any>": {
          "type": "object",
          "properties": {
            "target": {
              "type": "object",
              "properties": {
                "prototype": {},
                "length": {
                  "type": "number"
                },
                "arguments": {},
                "caller": {
                  "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                }
              },
              "required": ["prototype", "length", "arguments", "caller"],
              "description": "Target bind to this entity schema. Optional."
            },
            "name": {
              "type": "string",
              "description": "Entity name."
            },
            "tableName": {
              "type": "string",
              "description": "Table name."
            },
            "database": {
              "type": "string",
              "description": "Database name. Used in MySql and Sql Server."
            },
            "schema": {
              "type": "string",
              "description": "Schema name. Used in Postgres and Sql Server."
            },
            "type": {
              "$ref": "#/components/schemas/TableType",
              "description": "Table type."
            },
            "orderBy": {
              "$ref": "#/components/schemas/OrderByCondition",
              "description": "Specifies a property name by which queries will perform ordering by default when fetching rows."
            },
            "columns": {
              "type": "object",
              "description": "Entity column's options."
            },
            "relations": {
              "type": "object",
              "description": "Entity relation's options."
            },
            "relationIds": {
              "type": "object",
              "description": "Entity relation id options."
            },
            "indices": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntitySchemaIndexOptions"
              },
              "description": "Entity indices options."
            },
            "uniques": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntitySchemaUniqueOptions"
              },
              "description": "Entity uniques options."
            },
            "checks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntitySchemaCheckOptions"
              },
              "description": "Entity check options."
            },
            "exclusions": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntitySchemaExclusionOptions"
              },
              "description": "Entity exclusion options."
            },
            "embeddeds": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/EntitySchemaEmbeddedColumnOptions"
              },
              "description": "Embedded Entities options"
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if schema synchronization is enabled or disabled for this entity. If it will be set to false then schema sync will and migrations ignore this entity. By default schema synchronization is enabled for all entities."
            },
            "withoutRowid": {
              "type": "boolean",
              "description": "If set to 'true' this option disables Sqlite's default behaviour of secretly creating an integer primary key column named 'rowid' on table creation."
            },
            "expression": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$comment": "(connection: DataSource) => SelectQueryBuilder<any>",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "connection": {
                          "$ref": "#/components/schemas/DataSource"
                        }
                      },
                      "required": ["connection"],
                      "additionalProperties": false
                    }
                  }
                }
              ],
              "description": "View expression."
            },
            "inheritance": {
              "$ref": "#/components/schemas/EntitySchemaInheritanceOptions",
              "description": "Inheritance options."
            },
            "discriminatorValue": {
              "type": "string",
              "description": "Custom discriminator value for Single Table Inheritance."
            }
          },
          "required": ["name", "columns"],
          "description": "Interface for entity metadata mappings stored inside \"schemas\" instead of models decorated by decorators."
        },
        "TableType": {
          "type": "string",
          "enum": ["regular", "view", "junction", "closure", "closure-junction", "entity-child"],
          "description": "Table type. Tables can be closure, junction,, etc."
        },
        "OrderByCondition": {
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "const": "ASC"
              },
              {
                "type": "string",
                "const": "DESC"
              },
              {
                "type": "object",
                "properties": {
                  "order": {
                    "type": "string",
                    "enum": ["ASC", "DESC"]
                  },
                  "nulls": {
                    "type": "string",
                    "enum": ["NULLS FIRST", "NULLS LAST"]
                  }
                },
                "required": ["order"]
              }
            ]
          },
          "description": "Special object that defines order condition for ORDER BY in sql.\n\nExample: {  \"name\": \"ASC\",  \"id\": \"DESC\" }",
          "deprecated": true
        },
        "EntitySchemaIndexOptions": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Index name."
            },
            "columns": {
              "anyOf": [
                {
                  "$comment": "(object?: any) => any[] | {\n        [key: string]: number;\n    }",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "object": {}
                      },
                      "additionalProperties": false
                    }
                  }
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Index column names."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if index must sync with database index."
            },
            "sparse": {
              "type": "boolean",
              "description": "If true, the index only references documents with the specified field. These indexes use less space but behave differently in some situations (particularly sorts). This option is only supported for mongodb database."
            },
            "unique": {
              "type": "boolean",
              "description": "Indicates if this index must be unique or not."
            },
            "spatial": {
              "type": "boolean",
              "description": "The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values. Works only in MySQL and PostgreSQL."
            },
            "fulltext": {
              "type": "boolean",
              "description": "The FULLTEXT modifier indexes the entire column and does not allow prefixing. Works only in MySQL."
            },
            "nullFiltered": {
              "type": "boolean",
              "description": "NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value. In these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than a normal index that includes NULL values.\n\nWorks only in Spanner."
            },
            "parser": {
              "type": "string",
              "description": "Fulltext parser. Works only in MySQL."
            },
            "where": {
              "type": "string",
              "description": "Index filter condition."
            }
          }
        },
        "EntitySchemaUniqueOptions": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Unique constraint name."
            },
            "columns": {
              "anyOf": [
                {
                  "$comment": "(object?: any) => any[] | {\n        [key: string]: number;\n    }",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "object": {}
                      },
                      "additionalProperties": false
                    }
                  }
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Unique column names."
            },
            "deferrable": {
              "$ref": "#/components/schemas/DeferrableType",
              "description": "Indicate if unique constraints can be deferred."
            }
          }
        },
        "DeferrableType": {
          "type": "string",
          "enum": ["INITIALLY IMMEDIATE", "INITIALLY DEFERRED"],
          "description": "DEFERRABLE type to be used to specify if foreign key constraints can be deferred."
        },
        "EntitySchemaCheckOptions": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Check constraint name."
            },
            "expression": {
              "type": "string",
              "description": "Check expression."
            }
          },
          "required": ["expression"]
        },
        "EntitySchemaExclusionOptions": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Exclusion constraint name."
            },
            "expression": {
              "type": "string",
              "description": "Exclusion expression."
            }
          },
          "required": ["expression"]
        },
        "EntitySchemaEmbeddedColumnOptions": {
          "type": "object",
          "properties": {
            "schema": {
              "$ref": "#/components/schemas/EntitySchema",
              "description": "Schema of embedded entity"
            },
            "prefix": {
              "type": ["string", "boolean"],
              "description": "Embedded column prefix. If set to empty string or false, then prefix is not set at all."
            },
            "array": {
              "type": "boolean",
              "description": "Indicates if this embedded is in array mode.\n\nThis option works only in mongodb."
            }
          },
          "required": ["schema"]
        },
        "EntitySchemaInheritanceOptions": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string",
              "const": "STI",
              "description": "Inheritance pattern."
            },
            "column": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/ColumnOptions"
                }
              ],
              "description": "Inheritance discriminator column."
            }
          }
        },
        "ColumnOptions": {
          "type": "object",
          "properties": {
            "select": {
              "type": "boolean",
              "description": "Indicates if column is always selected by QueryBuilder and find operations. Default value is \"true\"."
            },
            "name": {
              "type": "string",
              "description": "Column name in the database."
            },
            "primary": {
              "type": "boolean",
              "description": "Indicates if this column is a primary key. Same can be achieved when"
            },
            "generated": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "string",
                  "const": "increment"
                },
                {
                  "type": "string",
                  "const": "uuid"
                },
                {
                  "type": "string",
                  "const": "rowid"
                },
                {
                  "type": "string",
                  "const": "identity"
                }
              ],
              "description": "Specifies if this column will use auto increment (sequence, generated identity, rowid). Note that in some databases only one column in entity can be marked as generated, and it must be a primary column."
            },
            "unique": {
              "type": "boolean",
              "description": "Specifies if column's value must be unique or not."
            },
            "nullable": {
              "type": "boolean",
              "description": "Indicates if column's value can be set to NULL. Default value is \"false\"."
            },
            "default": {
              "description": "Default database value."
            },
            "onUpdate": {
              "type": "string",
              "description": "ON UPDATE trigger. Works only for MySQL."
            },
            "comment": {
              "type": "string",
              "description": "Column comment. Not supported by all database types."
            },
            "array": {
              "type": "boolean",
              "description": "Indicates if this column is an array. Can be simply set to true or array length can be specified. Supported only by postgres."
            },
            "transformer": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ValueTransformer"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ValueTransformer"
                  }
                }
              ],
              "description": "Specifies a value transformer that is to be used to (un)marshal this column when reading or writing to the database."
            },
            "type": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type. Must be one of the value from the ColumnTypes class."
            },
            "length": {
              "type": ["string", "number"],
              "description": "Column type's length. Used only on some column types. For example type = \"string\" and length = \"100\" means that ORM will create a column with type varchar(100)."
            },
            "width": {
              "type": "number",
              "description": "Column type's display width. Used only on some column types in MySQL. For example, INT(4) specifies an INT with a display width of four digits."
            },
            "readonly": {
              "type": "boolean",
              "description": "Indicates if column value is not updated by \"save\" operation. It means you'll be able to write this value only when you first time insert the object. Default value is \"false\".",
              "deprecated": "Please use the `update` option instead.  Careful, it takes\nthe opposite value to readonly."
            },
            "update": {
              "type": "boolean",
              "description": "Indicates if column value is updated by \"save\" operation. If false, you'll be able to write this value only when you first time insert the object. Default value is \"true\"."
            },
            "insert": {
              "type": "boolean",
              "description": "Indicates if column is inserted by default. Default value is \"true\"."
            },
            "precision": {
              "type": ["number", "null"],
              "description": "The precision for a decimal (exact numeric) column (applies only for decimal column), which is the maximum number of digits that are stored for the values."
            },
            "scale": {
              "type": "number",
              "description": "The scale for a decimal (exact numeric) column (applies only for decimal column), which represents the number of digits to the right of the decimal point and must not be greater than precision."
            },
            "zerofill": {
              "type": "boolean",
              "description": "Puts ZEROFILL attribute on to numeric column. Works only for MySQL. If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to this column"
            },
            "unsigned": {
              "type": "boolean",
              "description": "Puts UNSIGNED attribute on to numeric column. Works only for MySQL."
            },
            "charset": {
              "type": "string",
              "description": "Defines a column character set. Not supported by all database types."
            },
            "collation": {
              "type": "string",
              "description": "Defines a column collation."
            },
            "enum": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": ["string", "number"]
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "constructor": {
                      "type": "object",
                      "properties": {
                        "prototype": {},
                        "length": {
                          "type": "number"
                        },
                        "arguments": {},
                        "caller": {
                          "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                        }
                      },
                      "required": ["prototype", "length", "arguments", "caller"]
                    }
                  },
                  "required": ["constructor"]
                }
              ],
              "description": "Array of possible enumerated values."
            },
            "enumName": {
              "type": "string",
              "description": "Exact name of enum"
            },
            "primaryKeyConstraintName": {
              "type": "string",
              "description": "If this column is primary key then this specifies the name for it."
            },
            "foreignKeyConstraintName": {
              "type": "string",
              "description": "If this column is foreign key then this specifies the name for it."
            },
            "asExpression": {
              "type": "string",
              "description": "Generated column expression."
            },
            "generatedType": {
              "type": "string",
              "enum": ["VIRTUAL", "STORED"],
              "description": "Generated column type."
            },
            "generatedIdentity": {
              "type": "string",
              "enum": ["ALWAYS", "BY DEFAULT"],
              "description": "Identity column type. Supports only in Postgres 10+."
            },
            "hstoreType": {
              "type": "string",
              "enum": ["object", "string"],
              "description": "Return type of HSTORE column. Returns value as string or as object."
            },
            "spatialFeatureType": {
              "type": "string",
              "description": "Spatial Feature Type (Geometry, Point, Polygon, etc.)"
            },
            "srid": {
              "type": "number",
              "description": "SRID (Spatial Reference ID (EPSG code))"
            }
          },
          "description": "Describes all column's options."
        },
        "ValueTransformer": {
          "type": "object",
          "description": "Interface for objects that deal with (un)marshalling data."
        },
        "ColumnType": {
          "anyOf": [
            {
              "$ref": "#/components/schemas/WithPrecisionColumnType"
            },
            {
              "$ref": "#/components/schemas/WithLengthColumnType"
            },
            {
              "$ref": "#/components/schemas/WithWidthColumnType"
            },
            {
              "$ref": "#/components/schemas/SpatialColumnType"
            },
            {
              "$ref": "#/components/schemas/SimpleColumnType"
            },
            {
              "type": "object",
              "properties": {
                "prototype": {
                  "type": "object"
                }
              },
              "required": ["prototype"]
            },
            {
              "type": "object",
              "properties": {
                "prototype": {
                  "type": "string",
                  "format": "date-time"
                }
              },
              "required": ["prototype"]
            },
            {
              "type": "object",
              "properties": {
                "prototype": {
                  "type": "object"
                },
                "MAX_VALUE": {
                  "type": "number"
                },
                "MIN_VALUE": {
                  "type": "number"
                },
                "NaN": {
                  "type": "number"
                },
                "NEGATIVE_INFINITY": {
                  "type": "number"
                },
                "POSITIVE_INFINITY": {
                  "type": "number"
                }
              },
              "required": ["prototype", "MAX_VALUE", "MIN_VALUE", "NaN", "NEGATIVE_INFINITY", "POSITIVE_INFINITY"]
            },
            {
              "type": "object",
              "properties": {
                "prototype": {
                  "type": "object",
                  "properties": {
                    "length": {
                      "type": "number"
                    }
                  },
                  "required": ["length"],
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              },
              "required": ["prototype"]
            }
          ],
          "description": "Any column type column can be."
        },
        "WithPrecisionColumnType": {
          "type": "string",
          "enum": [
            "float",
            "double",
            "dec",
            "decimal",
            "smalldecimal",
            "fixed",
            "numeric",
            "real",
            "double precision",
            "number",
            "datetime",
            "datetime2",
            "datetimeoffset",
            "time",
            "time with time zone",
            "time without time zone",
            "timestamp",
            "timestamp without time zone",
            "timestamp with time zone",
            "timestamp with local time zone"
          ],
          "description": "Column types where precision and scale properties are used."
        },
        "WithLengthColumnType": {
          "type": "string",
          "enum": [
            "character varying",
            "varying character",
            "char varying",
            "nvarchar",
            "national varchar",
            "character",
            "native character",
            "varchar",
            "char",
            "nchar",
            "national char",
            "varchar2",
            "nvarchar2",
            "alphanum",
            "shorttext",
            "raw",
            "binary",
            "varbinary",
            "string"
          ],
          "description": "Column types where column length is used."
        },
        "WithWidthColumnType": {
          "type": "string",
          "enum": ["tinyint", "smallint", "mediumint", "int", "bigint"]
        },
        "SpatialColumnType": {
          "type": "string",
          "enum": ["geometry", "geography", "st_geometry", "st_point"],
          "description": "Column types where spatial properties are used."
        },
        "SimpleColumnType": {
          "type": "string",
          "enum": [
            "simple-array",
            "simple-json",
            "simple-enum",
            "int2",
            "integer",
            "int4",
            "int8",
            "int64",
            "unsigned big int",
            "float",
            "float4",
            "float8",
            "float64",
            "smallmoney",
            "money",
            "boolean",
            "bool",
            "tinyblob",
            "tinytext",
            "mediumblob",
            "mediumtext",
            "blob",
            "text",
            "ntext",
            "citext",
            "hstore",
            "longblob",
            "longtext",
            "alphanum",
            "shorttext",
            "bytes",
            "bytea",
            "long",
            "raw",
            "long raw",
            "bfile",
            "clob",
            "nclob",
            "image",
            "timetz",
            "timestamptz",
            "timestamp with local time zone",
            "smalldatetime",
            "date",
            "interval year to month",
            "interval day to second",
            "interval",
            "year",
            "seconddate",
            "point",
            "line",
            "lseg",
            "box",
            "circle",
            "path",
            "polygon",
            "geography",
            "geometry",
            "linestring",
            "multipoint",
            "multilinestring",
            "multipolygon",
            "geometrycollection",
            "st_geometry",
            "st_point",
            "int4range",
            "int8range",
            "numrange",
            "tsrange",
            "tstzrange",
            "daterange",
            "int4multirange",
            "int8multirange",
            "nummultirange",
            "tsmultirange",
            "tstzmultirange",
            "datemultirange",
            "enum",
            "set",
            "cidr",
            "inet",
            "inet4",
            "inet6",
            "macaddr",
            "bit",
            "bit varying",
            "varbit",
            "tsvector",
            "tsquery",
            "uuid",
            "xml",
            "json",
            "jsonb",
            "varbinary",
            "hierarchyid",
            "sql_variant",
            "rowid",
            "urowid",
            "uniqueidentifier",
            "rowversion",
            "array",
            "cube",
            "ltree"
          ],
          "description": "All other regular column types."
        },
        "MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>": {
          "anyOf": [
            {
              "type": "array",
              "items": {
                "anyOf": [
                  {
                    "type": "object",
                    "properties": {
                      "prototype": {},
                      "length": {
                        "type": "number"
                      },
                      "arguments": {},
                      "caller": {
                        "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                      }
                    },
                    "required": ["prototype", "length", "arguments", "caller"]
                  },
                  {
                    "type": "string"
                  }
                ]
              }
            },
            {
              "type": "object",
              "additionalProperties": {
                "anyOf": [
                  {
                    "type": "object",
                    "properties": {
                      "prototype": {},
                      "length": {
                        "type": "number"
                      },
                      "arguments": {},
                      "caller": {
                        "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                      }
                    },
                    "required": ["prototype", "length", "arguments", "caller"]
                  },
                  {
                    "type": "string"
                  }
                ]
              }
            }
          ],
          "description": "List of T-s passed as an array or object map.\n\nExample usage: entities as an array of imported using import * as syntax."
        },
        "NamingStrategyInterface": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Naming strategy name."
            },
            "nestedSetColumnNames": {
              "type": "object",
              "properties": {
                "left": {
                  "type": "string"
                },
                "right": {
                  "type": "string"
                }
              },
              "required": ["left", "right"],
              "description": "Column names for nested sets."
            },
            "materializedPathColumnName": {
              "type": "string",
              "description": "Column name for materialized paths."
            }
          },
          "required": ["nestedSetColumnNames", "materializedPathColumnName"],
          "description": "Naming strategy defines how auto-generated names for such things like table name, or table column gonna be generated."
        },
        "LoggerOptions": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "string",
              "const": "all"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/LogLevel"
              }
            }
          ],
          "description": "Logging options."
        },
        "LogLevel": {
          "type": "string",
          "enum": ["query", "schema", "error", "warn", "info", "log", "migration"],
          "description": "Log level."
        },
        "Logger": {
          "type": "object",
          "description": "Performs logging of the events in TypeORM."
        },
        "MysqlConnectionCredentialsOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "ssl": {
              "description": "Object with ssl parameters or a string containing name of ssl profile."
            },
            "socketPath": {
              "type": "string",
              "description": "Database socket path"
            }
          },
          "description": "MySQL specific connection credential options."
        },
        "ReplicationMode": {
          "type": "string",
          "enum": ["master", "slave"]
        },
        "PostgresConnectionOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$comment": "() => Promise<string>"
                }
              ],
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "ssl": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "$ref": "#/components/schemas/TlsOptions"
                }
              ],
              "description": "Object with ssl parameters"
            },
            "applicationName": {
              "type": "string",
              "description": "sets the application_name var to help db administrators identify the service using this connection. Defaults to 'undefined'"
            },
            "type": {
              "type": "string",
              "const": "postgres",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "type": "number",
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "schema": {
              "type": "string",
              "description": "Schema name."
            },
            "driver": {
              "description": "The driver object This defaults to `require(\"pg\")`."
            },
            "nativeDriver": {
              "description": "The driver object This defaults to `require(\"pg-native\")`."
            },
            "useUTC": {
              "type": "boolean",
              "description": "A boolean determining whether to pass time values in UTC or local time. (default: false)."
            },
            "replication": {
              "type": "object",
              "properties": {
                "master": {
                  "$ref": "#/components/schemas/PostgresConnectionCredentialsOptions",
                  "description": "Master server used by orm to perform writes."
                },
                "slaves": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PostgresConnectionCredentialsOptions"
                  },
                  "description": "List of read-from servers (slaves)."
                },
                "defaultMode": {
                  "$ref": "#/components/schemas/ReplicationMode",
                  "description": "Default connection pool to use for SELECT queries",
                  "default": "slave"
                }
              },
              "required": ["master", "slaves"],
              "description": "Replication setup."
            },
            "connectTimeoutMS": {
              "type": "number",
              "description": "The milliseconds before a timeout occurs during the initial connection to the postgres server. If undefined, or set to 0, there is no timeout. Defaults to undefined."
            },
            "uuidExtension": {
              "type": "string",
              "enum": ["pgcrypto", "uuid-ossp"],
              "description": "The Postgres extension to use to generate UUID columns. Defaults to uuid-ossp. If pgcrypto is selected, TypeORM will use the gen_random_uuid() function from this extension. If uuid-ossp is selected, TypeORM will use the uuid_generate_v4() function from this extension."
            },
            "poolErrorHandler": {
              "$comment": "(err: any) => any",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "err": {}
                  },
                  "required": ["err"],
                  "additionalProperties": false
                }
              }
            },
            "logNotifications": {
              "type": "boolean",
              "description": "Include notification messages from Postgres server in client logs"
            },
            "installExtensions": {
              "type": "boolean",
              "description": "Automatically install postgres extensions"
            },
            "parseInt8": {
              "type": "boolean",
              "description": "Return 64-bit integers (int8) as JavaScript integers.\n\nBecause JavaScript doesn't have support for 64-bit integers node-postgres cannot confidently parse int8 data type results as numbers because if you have a huge number it will overflow and the result you'd get back from node-postgres would not be the result in the database. That would be a very bad thing so node-postgres just returns int8 results as strings and leaves the parsing up to you.\n\nEnabling parseInt8 will cause node-postgres to parse int8 results as numbers. Note: the maximum safe integer in js is: Number.MAX_SAFE_INTEGER (`+2^53`)"
            }
          },
          "required": ["type"],
          "description": "Postgres-specific connection options."
        },
        "TlsOptions": {
          "type": "object",
          "properties": {
            "allowHalfOpen": {
              "type": "boolean",
              "description": "Indicates whether half-opened TCP connections are allowed.",
              "default": false
            },
            "pauseOnConnect": {
              "type": "boolean",
              "description": "Indicates whether the socket should be paused on incoming connections.",
              "default": false
            },
            "noDelay": {
              "type": "boolean",
              "description": "If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.",
              "default": false
            },
            "keepAlive": {
              "type": "boolean",
              "description": "If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received, similarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.",
              "default": false
            },
            "keepAliveInitialDelay": {
              "type": "number",
              "description": "If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.",
              "default": 0
            },
            "highWaterMark": {
              "type": "number",
              "description": "Optionally overrides all `net.Socket`s' `readableHighWaterMark` and `writableHighWaterMark`.",
              "default": "See [stream.getDefaultHighWaterMark()](https://nodejs.org/docs/latest-v20.x/api/stream.html#streamgetdefaulthighwatermarkobjectmode)."
            },
            "secureContext": {
              "$ref": "#/components/schemas/SecureContext",
              "description": "An optional TLS context object from tls.createSecureContext()"
            },
            "enableTrace": {
              "type": "boolean",
              "description": "When enabled, TLS packet trace information is written to `stderr`. This can be used to debug TLS connection problems.",
              "default": false
            },
            "requestCert": {
              "type": "boolean",
              "description": "If true the server will request a certificate from clients that connect and attempt to verify that certificate. Defaults to false."
            },
            "ALPNProtocols": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "BYTES_PER_ELEMENT": {
                        "type": "number"
                      },
                      "buffer": {
                        "anyOf": [
                          {
                            "type": "object",
                            "properties": {
                              "byteLength": {
                                "type": "number"
                              }
                            },
                            "required": ["byteLength"]
                          },
                          {}
                        ]
                      },
                      "byteLength": {
                        "type": "number"
                      },
                      "byteOffset": {
                        "type": "number"
                      },
                      "length": {
                        "type": "number"
                      }
                    },
                    "required": ["BYTES_PER_ELEMENT", "buffer", "byteLength", "byteOffset", "length"],
                    "additionalProperties": {
                      "type": "number"
                    }
                  }
                },
                {
                  "type": "object",
                  "properties": {
                    "BYTES_PER_ELEMENT": {
                      "type": "number"
                    },
                    "buffer": {
                      "anyOf": [
                        {
                          "type": "object",
                          "properties": {
                            "byteLength": {
                              "type": "number"
                            }
                          },
                          "required": ["byteLength"]
                        },
                        {}
                      ]
                    },
                    "byteLength": {
                      "type": "number"
                    },
                    "byteOffset": {
                      "type": "number"
                    },
                    "length": {
                      "type": "number"
                    }
                  },
                  "required": ["BYTES_PER_ELEMENT", "buffer", "byteLength", "byteOffset", "length"],
                  "additionalProperties": {
                    "type": "number"
                  }
                }
              ],
              "description": "An array of strings or a Buffer naming possible ALPN protocols. (Protocols should be ordered by their priority.)"
            },
            "SNICallback": {
              "$comment": "(servername: string, cb: (err: Error | null, ctx?: SecureContext) => void) => void",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "servername": {
                      "type": "string"
                    },
                    "cb": {
                      "$comment": "(err: Error | null, ctx?: SecureContext) => void",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "err": {
                              "anyOf": [
                                {
                                  "type": "object",
                                  "properties": {
                                    "name": {
                                      "type": "string"
                                    },
                                    "message": {
                                      "type": "string"
                                    },
                                    "stack": {
                                      "type": "string"
                                    }
                                  },
                                  "required": ["name", "message"]
                                },
                                {
                                  "type": "null"
                                }
                              ]
                            },
                            "ctx": {
                              "$ref": "#/components/schemas/SecureContext"
                            }
                          },
                          "required": ["err"],
                          "additionalProperties": false
                        }
                      }
                    }
                  },
                  "required": ["servername", "cb"],
                  "additionalProperties": false
                }
              },
              "description": "SNICallback(servername, cb) <Function> A function that will be called if the client supports SNI TLS extension. Two arguments will be passed when called: servername and cb. SNICallback should invoke cb(null, ctx), where ctx is a SecureContext instance. (tls.createSecureContext(...) can be used to get a proper SecureContext.) If SNICallback wasn't provided the default callback with high-level API will be used (see below)."
            },
            "rejectUnauthorized": {
              "type": "boolean",
              "description": "If true the server will reject any connection which is not authorized with the list of supplied CAs. This option only has an effect if requestCert is true.",
              "default": true
            },
            "ALPNCallback": {
              "$comment": "(arg: { servername: string; protocols: string[] }) => string | undefined",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "arg": {
                      "type": "object",
                      "properties": {
                        "servername": {
                          "type": "string"
                        },
                        "protocols": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      },
                      "required": ["servername", "protocols"]
                    }
                  },
                  "required": ["arg"],
                  "additionalProperties": false
                }
              },
              "description": "If set, this will be called when a client opens a connection using the ALPN extension. One argument will be passed to the callback: an object containing `servername` and `protocols` fields, respectively containing the server name from the SNI extension (if any) and an array of ALPN protocol name strings. The callback must return either one of the strings listed in `protocols`, which will be returned to the client as the selected ALPN protocol, or `undefined`, to reject the connection with a fatal alert. If a string is returned that does not match one of the client's ALPN protocols, an error will be thrown. This option cannot be used with the `ALPNProtocols` option, and setting both options will throw an error."
            },
            "ca": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                },
                {
                  "type": "array",
                  "items": {
                    "anyOf": [
                      {
                        "type": "string"
                      },
                      {
                        "$ref": "#/components/schemas/global.Buffer"
                      }
                    ]
                  }
                }
              ],
              "description": "Optionally override the trusted CA certificates. Default is to trust the well-known CAs curated by Mozilla. Mozilla's CAs are completely replaced when CAs are explicitly specified using this option."
            },
            "cert": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                },
                {
                  "type": "array",
                  "items": {
                    "anyOf": [
                      {
                        "type": "string"
                      },
                      {
                        "$ref": "#/components/schemas/global.Buffer"
                      }
                    ]
                  }
                }
              ],
              "description": "Cert chains in PEM format. One cert chain should be provided per private key. Each cert chain should consist of the PEM formatted certificate for a provided private key, followed by the PEM formatted intermediate certificates (if any), in order, and not including the root CA (the root CA must be pre-known to the peer, see ca). When providing multiple cert chains, they do not have to be in the same order as their private keys in key. If the intermediate certificates are not provided, the peer will not be able to validate the certificate, and the handshake will fail."
            },
            "sigalgs": {
              "type": "string",
              "description": "Colon-separated list of supported signature algorithms. The list can contain digest algorithms (SHA256, MD5 etc.), public key algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g 'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512)."
            },
            "ciphers": {
              "type": "string",
              "description": "Cipher suite specification, replacing the default. For more information, see modifying the default cipher suite. Permitted ciphers can be obtained via tls.getCiphers(). Cipher names must be uppercased in order for OpenSSL to accept them."
            },
            "clientCertEngine": {
              "type": "string",
              "description": "Name of an OpenSSL engine which can provide the client certificate."
            },
            "crl": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                },
                {
                  "type": "array",
                  "items": {
                    "anyOf": [
                      {
                        "type": "string"
                      },
                      {
                        "$ref": "#/components/schemas/global.Buffer"
                      }
                    ]
                  }
                }
              ],
              "description": "PEM formatted CRLs (Certificate Revocation Lists)."
            },
            "dhparam": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                }
              ],
              "description": "`'auto'` or custom Diffie-Hellman parameters, required for non-ECDHE perfect forward secrecy. If omitted or invalid, the parameters are silently discarded and DHE ciphers will not be available. ECDHE-based perfect forward secrecy will still be available."
            },
            "ecdhCurve": {
              "type": "string",
              "description": "A string describing a named curve or a colon separated list of curve NIDs or names, for example P-521:P-384:P-256, to use for ECDH key agreement. Set to auto to select the curve automatically. Use crypto.getCurves() to obtain a list of available curve names. On recent releases, openssl ecparam -list_curves will also display the name and description of each available elliptic curve. Default: tls.DEFAULT_ECDH_CURVE."
            },
            "honorCipherOrder": {
              "type": "boolean",
              "description": "Attempt to use the server's cipher suite preferences instead of the client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be set in secureOptions"
            },
            "key": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                },
                {
                  "type": "array",
                  "items": {
                    "anyOf": [
                      {
                        "type": "string"
                      },
                      {
                        "$ref": "#/components/schemas/global.Buffer"
                      },
                      {
                        "$ref": "#/components/schemas/KeyObject"
                      }
                    ]
                  }
                }
              ],
              "description": "Private keys in PEM format. PEM allows the option of private keys being encrypted. Encrypted keys will be decrypted with options.passphrase. Multiple keys using different algorithms can be provided either as an array of unencrypted key strings or buffers, or an array of objects in the form {pem: <string|buffer>[, passphrase: <string>]}. The object form can only occur in an array. object.passphrase is optional. Encrypted keys will be decrypted with object.passphrase if provided, or options.passphrase if it is not."
            },
            "privateKeyEngine": {
              "type": "string",
              "description": "Name of an OpenSSL engine to get private key from. Should be used together with privateKeyIdentifier."
            },
            "privateKeyIdentifier": {
              "type": "string",
              "description": "Identifier of a private key managed by an OpenSSL engine. Should be used together with privateKeyEngine. Should not be set together with key, because both options define a private key in different ways."
            },
            "maxVersion": {
              "$ref": "#/components/schemas/SecureVersion",
              "description": "Optionally set the maximum TLS version to allow. One of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the `secureProtocol` option, use one or the other.\n**Default:** `'TLSv1.3'`, unless changed using CLI options. Using `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to `'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used."
            },
            "minVersion": {
              "$ref": "#/components/schemas/SecureVersion",
              "description": "Optionally set the minimum TLS version to allow. One of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the `secureProtocol` option, use one or the other.  It is not recommended to use less than TLSv1.2, but it may be required for interoperability.\n**Default:** `'TLSv1.2'`, unless changed using CLI options. Using `--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to `'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to 'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used."
            },
            "passphrase": {
              "type": "string",
              "description": "Shared passphrase used for a single private key and/or a PFX."
            },
            "pfx": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                },
                {
                  "type": "array",
                  "items": {
                    "anyOf": [
                      {
                        "type": "string"
                      },
                      {
                        "$ref": "#/components/schemas/global.Buffer"
                      },
                      {
                        "$ref": "#/components/schemas/PxfObject"
                      }
                    ]
                  }
                }
              ],
              "description": "PFX or PKCS12 encoded private key and certificate chain. pfx is an alternative to providing key and cert individually. PFX is usually encrypted, if it is, passphrase will be used to decrypt it. Multiple PFX can be provided either as an array of unencrypted PFX buffers, or an array of objects in the form {buf: <string|buffer>[, passphrase: <string>]}. The object form can only occur in an array. object.passphrase is optional. Encrypted PFX will be decrypted with object.passphrase if provided, or options.passphrase if it is not."
            },
            "secureOptions": {
              "type": "number",
              "description": "Optionally affect the OpenSSL protocol behavior, which is not usually necessary. This should be used carefully if at all! Value is a numeric bitmask of the SSL_OP_* options from OpenSSL Options"
            },
            "secureProtocol": {
              "type": "string",
              "description": "Legacy mechanism to select the TLS protocol version to use, it does not support independent control of the minimum and maximum version, and does not support limiting the protocol to TLSv1.3. Use minVersion and maxVersion instead. The possible values are listed as SSL_METHODS, use the function names as strings. For example, use 'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow any TLS protocol version up to TLSv1.3. It is not recommended to use TLS versions less than 1.2, but it may be required for interoperability. Default: none, see minVersion."
            },
            "sessionIdContext": {
              "type": "string",
              "description": "Opaque identifier used by servers to ensure session state is not shared between applications. Unused by clients."
            },
            "ticketKeys": {
              "$ref": "#/components/schemas/global.Buffer",
              "description": "48-bytes of cryptographically strong pseudo-random data."
            },
            "sessionTimeout": {
              "type": "number",
              "description": "The number of seconds after which a TLS session created by the server will no longer be resumable. See Session Resumption for more information. Default: 300."
            },
            "handshakeTimeout": {
              "type": "number",
              "description": "Abort the connection if the SSL/TLS handshake does not finish in the specified number of milliseconds. A 'tlsClientError' is emitted on the tls.Server object whenever a handshake times out. Default: 120000 (120 seconds)."
            },
            "pskIdentityHint": {
              "type": "string",
              "description": "hint to send to a client to help with selecting the identity during TLS-PSK negotiation. Will be ignored in TLS 1.3. Upon failing to set pskIdentityHint `tlsClientError` will be emitted with `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED` code."
            }
          }
        },
        "SecureContext": {
          "type": "object",
          "properties": {
            "context": {}
          },
          "required": ["context"]
        },
        "global.Buffer": {
          "type": "object",
          "properties": {
            "BYTES_PER_ELEMENT": {
              "type": "number"
            },
            "buffer": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "byteLength": {
                      "type": "number"
                    }
                  },
                  "required": ["byteLength"]
                },
                {}
              ]
            },
            "byteLength": {
              "type": "number"
            },
            "byteOffset": {
              "type": "number"
            },
            "length": {
              "type": "number"
            }
          },
          "required": ["BYTES_PER_ELEMENT", "buffer", "byteLength", "byteOffset", "length"]
        },
        "KeyObject": {
          "type": "object",
          "properties": {
            "pem": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                }
              ],
              "description": "Private keys in PEM format."
            },
            "passphrase": {
              "type": "string",
              "description": "Optional passphrase."
            }
          },
          "required": ["pem"]
        },
        "SecureVersion": {
          "type": "string",
          "enum": ["TLSv1.3", "TLSv1.2", "TLSv1.1", "TLSv1"]
        },
        "PxfObject": {
          "type": "object",
          "properties": {
            "buf": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                }
              ],
              "description": "PFX or PKCS12 encoded private key and certificate chain."
            },
            "passphrase": {
              "type": "string",
              "description": "Optional passphrase."
            }
          },
          "required": ["buf"]
        },
        "PostgresConnectionCredentialsOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$comment": "() => Promise<string>"
                }
              ],
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "ssl": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "$ref": "#/components/schemas/TlsOptions"
                }
              ],
              "description": "Object with ssl parameters"
            },
            "applicationName": {
              "type": "string",
              "description": "sets the application_name var to help db administrators identify the service using this connection. Defaults to 'undefined'"
            }
          },
          "description": "Postgres specific connection credential options."
        },
        "CockroachConnectionOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "ssl": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "$ref": "#/components/schemas/TlsOptions"
                }
              ],
              "description": "Object with ssl parameters"
            },
            "type": {
              "type": "string",
              "const": "cockroachdb",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "type": "number",
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "timeTravelQueries": {
              "type": "boolean",
              "description": "Enable time travel queries on cockroachdb. https://www.cockroachlabs.com/docs/stable/as-of-system-time.html"
            },
            "schema": {
              "type": "string",
              "description": "Schema name."
            },
            "driver": {
              "description": "The driver object This defaults to `require(\"pg\")`."
            },
            "nativeDriver": {
              "description": "The driver object This defaults to `require(\"pg-native\")`."
            },
            "replication": {
              "type": "object",
              "properties": {
                "master": {
                  "$ref": "#/components/schemas/CockroachConnectionCredentialsOptions",
                  "description": "Master server used by orm to perform writes."
                },
                "slaves": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CockroachConnectionCredentialsOptions"
                  },
                  "description": "List of read-from servers (slaves)."
                },
                "defaultMode": {
                  "$ref": "#/components/schemas/ReplicationMode",
                  "description": "Default connection pool to use for SELECT queries",
                  "default": "slave"
                }
              },
              "required": ["master", "slaves"],
              "description": "Replication setup."
            },
            "applicationName": {
              "type": "string",
              "description": "sets the application_name var to help db administrators identify the service using this connection. Defaults to 'undefined'"
            },
            "poolErrorHandler": {
              "$comment": "(err: any) => any",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "err": {}
                  },
                  "required": ["err"],
                  "additionalProperties": false
                }
              },
              "description": "Function handling errors thrown by drivers pool. Defaults to logging error with `warn` level."
            },
            "maxTransactionRetries": {
              "type": "number",
              "description": "Max number of transaction retries in case of 40001 error."
            }
          },
          "required": ["timeTravelQueries", "type"],
          "description": "Cockroachdb-specific connection options."
        },
        "CockroachConnectionCredentialsOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "ssl": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "$ref": "#/components/schemas/TlsOptions"
                }
              ],
              "description": "Object with ssl parameters"
            }
          },
          "description": "Cockroachdb specific connection credential options."
        },
        "SqliteConnectionOptions": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "sqlite",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "database": {
              "type": "string",
              "description": "Storage type or path to the storage."
            },
            "driver": {
              "description": "The driver object This defaults to require(\"sqlite3\")"
            },
            "key": {
              "type": "string",
              "description": "Encryption key for for SQLCipher."
            },
            "busyErrorRetry": {
              "type": "number",
              "description": "In your SQLite application when you perform parallel writes its common to face SQLITE_BUSY error. This error indicates that SQLite failed to write to the database file since someone else already writes into it. Since SQLite cannot handle parallel saves this error cannot be avoided.\n\nTo simplify life's of those who have this error this particular option sets a timeout within which ORM will try to perform requested write operation again and again until it receives SQLITE_BUSY error.\n\nEnabling WAL can improve your app performance and face less SQLITE_BUSY issues. Time in milliseconds."
            },
            "enableWAL": {
              "type": "boolean",
              "description": "Enables WAL mode. By default its disabled."
            },
            "flags": {
              "type": "number",
              "description": "Specifies the open file flags. By default its undefined."
            },
            "busyTimeout": {
              "type": "number",
              "description": "Query or change the setting of the busy timeout. Time in milliseconds."
            }
          },
          "required": ["database", "type"],
          "description": "Sqlite-specific connection options."
        },
        "SqlServerConnectionOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "authentication": {
              "$ref": "#/components/schemas/SqlServerConnectionCredentialsAuthenticationOptions",
              "description": "Authentication settings It overrides username and password, when passed."
            },
            "domain": {
              "type": "string",
              "description": "Once you set domain, driver will connect to SQL Server using domain login.",
              "deprecated": true
            },
            "type": {
              "type": "string",
              "const": "mssql",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "connectionTimeout": {
              "type": "number",
              "description": "Connection timeout in ms (default: 15000)."
            },
            "requestTimeout": {
              "type": "number",
              "description": "Request timeout in ms (default: 15000). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second."
            },
            "stream": {
              "type": "boolean",
              "description": "Stream recordsets/rows instead of returning them all at once as an argument of callback (default: false). You can also enable streaming for each request independently (request.stream = true). Always set to true if you plan to work with large amount of rows."
            },
            "schema": {
              "type": "string",
              "description": "Database schema."
            },
            "driver": {
              "description": "The driver object This defaults to `require(\"mssql\")`"
            },
            "pool": {
              "type": "object",
              "properties": {
                "max": {
                  "type": "number",
                  "description": "Maximum number of resources to create at any given time. (default=1)"
                },
                "min": {
                  "type": "number",
                  "description": "Minimum number of resources to keep in pool at any given time. If this is set >= max, the pool will silently set the min to equal max. (default=0)"
                },
                "maxWaitingClients": {
                  "type": "number",
                  "description": "Maximum number of queued requests allowed, additional acquire calls will be callback with an err in a future cycle of the event loop."
                },
                "acquireTimeoutMillis": {
                  "type": "number",
                  "description": "Max milliseconds an acquire call will wait for a resource before timing out. (default no limit), if supplied should non-zero positive integer."
                },
                "fifo": {
                  "type": "boolean",
                  "description": "If true the oldest resources will be first to be allocated. If false the most recently released resources will be the first to be allocated. This in effect turns the pool's behaviour from a queue into a stack. boolean, (default true)"
                },
                "priorityRange": {
                  "type": "number",
                  "description": "Int between 1 and x - if set, borrowers can specify their relative priority in the queue if no resources are available. see example. (default 1)"
                },
                "evictionRunIntervalMillis": {
                  "type": "number",
                  "description": "How often to run eviction checks. Default: 0 (does not run)."
                },
                "numTestsPerRun": {
                  "type": "number",
                  "description": "Number of resources to check each eviction run. Default: 3."
                },
                "softIdleTimeoutMillis": {
                  "type": "number",
                  "description": "Amount of time an object may sit idle in the pool before it is eligible for eviction by the idle object evictor (if any), with the extra condition that at least \"min idle\" object instances remain in the pool. Default -1 (nothing can get evicted)"
                },
                "idleTimeoutMillis": {
                  "type": "number",
                  "description": "The minimum amount of time that an object may sit idle in the pool before it is eligible for eviction due to idle time. Supercedes softIdleTimeoutMillis Default: 30000"
                },
                "errorHandler": {
                  "$comment": "(err: any) => any",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "err": {}
                      },
                      "required": ["err"],
                      "additionalProperties": false
                    }
                  }
                }
              },
              "description": "An optional object/dictionary with the any of the properties"
            },
            "options": {
              "type": "object",
              "properties": {
                "instanceName": {
                  "type": "string",
                  "description": "The named instance to connect to"
                },
                "fallbackToDefaultDb": {
                  "type": "boolean",
                  "description": "By default, if the database requestion by options.database cannot be accessed, the connection will fail with an error. However, if options.fallbackToDefaultDb is set to true, then the user's default database will be used instead (Default: false)."
                },
                "enableAnsiNullDefault": {
                  "type": "boolean",
                  "description": "If true, SET ANSI_NULL_DFLT_ON ON will be set in the initial sql. This means new columns will be nullable by default. See the T-SQL documentation for more details. (Default: true)."
                },
                "connectTimeout": {
                  "type": "number",
                  "description": "The number of milliseconds before the attempt to connect is considered failed (default: 15000)."
                },
                "cancelTimeout": {
                  "type": "number",
                  "description": "The number of milliseconds before the cancel (abort) of a request is considered failed (default: 5000)."
                },
                "packetSize": {
                  "type": "number",
                  "description": "The size of TDS packets (subject to negotiation with the server). Should be a power of 2. (default: 4096)."
                },
                "useUTC": {
                  "type": "boolean",
                  "description": "A boolean determining whether to pass time values in UTC or local time. (default: false)."
                },
                "abortTransactionOnError": {
                  "type": "boolean",
                  "description": "A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for SET XACT_ABORT during the initial SQL phase of a connection (documentation)."
                },
                "localAddress": {
                  "type": "string",
                  "description": "A string indicating which network interface (ip address) to use when connecting to SQL Server."
                },
                "useColumnNames": {
                  "type": "boolean",
                  "description": "A boolean determining whether to return rows as arrays or key-value collections. (default: false)."
                },
                "camelCaseColumns": {
                  "type": "boolean",
                  "description": "A boolean, controlling whether the column names returned will have the first letter converted to lower case (true) or not. This value is ignored if you provide a columnNameReplacer. (default: false)."
                },
                "disableOutputReturning": {
                  "type": "boolean",
                  "description": "A boolean, controlling whatever to disable RETURNING / OUTPUT statements."
                },
                "disableAsciiToUnicodeParamConversion": {
                  "type": "boolean",
                  "description": "A boolean, controlling whether MssqlParameter types char, varchar, and text are converted to their unicode equivalents, nchar, nvarchar, and ntext. (default: false, meaning that char/varchar/text parameters will be converted to nchar/nvarchar/ntext)"
                },
                "debug": {
                  "type": "object",
                  "properties": {
                    "packet": {
                      "type": "boolean",
                      "description": "A boolean, controlling whether debug events will be emitted with text describing packet details (default: false)."
                    },
                    "data": {
                      "type": "boolean",
                      "description": "A boolean, controlling whether debug events will be emitted with text describing packet data details (default: false)."
                    },
                    "payload": {
                      "type": "boolean",
                      "description": "A boolean, controlling whether debug events will be emitted with text describing packet payload details (default: false)."
                    },
                    "token": {
                      "type": "boolean",
                      "description": "A boolean, controlling whether debug events will be emitted with text describing token stream tokens (default: false)."
                    }
                  },
                  "description": "Debug options"
                },
                "isolation": {
                  "type": "string",
                  "enum": ["READ_UNCOMMITTED", "READ_COMMITTED", "REPEATABLE_READ", "SERIALIZABLE", "SNAPSHOT"],
                  "description": "The default isolation level that transactions will be run with. The isolation levels are available from require('tedious').ISOLATION_LEVEL. (default: READ_COMMITTED)."
                },
                "connectionIsolationLevel": {
                  "type": "string",
                  "enum": ["READ_UNCOMMITTED", "READ_COMMITTED", "REPEATABLE_READ", "SERIALIZABLE", "SNAPSHOT"],
                  "description": "The default isolation level for new connections. All out-of-transaction queries are executed with this setting. The isolation levels are available from require('tedious').ISOLATION_LEVEL ."
                },
                "readOnlyIntent": {
                  "type": "boolean",
                  "description": "A boolean, determining whether the connection will request read only access from a SQL Server Availability Group. For more information, see here. (default: false)."
                },
                "encrypt": {
                  "type": "boolean",
                  "description": "A boolean determining whether or not the connection will be encrypted. Set to true if you're on Windows Azure. (default: true)."
                },
                "cryptoCredentialsDetails": {
                  "description": "When encryption is used, an object may be supplied that will be used for the first argument when calling tls.createSecurePair (default: {})."
                },
                "rowCollectionOnDone": {
                  "type": "boolean",
                  "description": "A boolean, that when true will expose received rows in Requests' done* events. See done, doneInProc and doneProc. (default: false) Caution: If many row are received, enabling this option could result in excessive memory usage."
                },
                "rowCollectionOnRequestCompletion": {
                  "type": "boolean",
                  "description": "A boolean, that when true will expose received rows in Requests' completion callback. See new Request. (default: false) Caution: If many row are received, enabling this option could result in excessive memory usage."
                },
                "tdsVersion": {
                  "type": "string",
                  "description": "The version of TDS to use. If server doesn't support specified version, negotiated version is used instead. The versions are available from require('tedious').TDS_VERSION. (default: 7_4)."
                },
                "enableArithAbort": {
                  "type": "boolean",
                  "description": "A boolean, that when true will abort a query when an overflow or divide-by-zero error occurs during query execution."
                },
                "appName": {
                  "type": "string",
                  "description": "Application name used for identifying a specific application in profiling, logging or tracing tools of SQL Server. (default: node-mssql)"
                },
                "trustServerCertificate": {
                  "type": "boolean",
                  "description": "A boolean, controlling whether encryption occurs if there is no verifiable server certificate. (default: false)"
                }
              },
              "description": "Extra options"
            },
            "replication": {
              "type": "object",
              "properties": {
                "master": {
                  "$ref": "#/components/schemas/SqlServerConnectionCredentialsOptions",
                  "description": "Master server used by orm to perform writes."
                },
                "slaves": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SqlServerConnectionCredentialsOptions"
                  },
                  "description": "List of read-from servers (slaves)."
                },
                "defaultMode": {
                  "$ref": "#/components/schemas/ReplicationMode",
                  "description": "Default connection pool to use for SELECT queries",
                  "default": "slave"
                }
              },
              "required": ["master", "slaves"],
              "description": "Replication setup."
            }
          },
          "required": ["type"],
          "description": "Microsoft Sql Server specific connection options."
        },
        "SqlServerConnectionCredentialsAuthenticationOptions": {
          "anyOf": [
            {
              "$ref": "#/components/schemas/DefaultAuthentication"
            },
            {
              "$ref": "#/components/schemas/NtlmAuthentication"
            },
            {
              "$ref": "#/components/schemas/AzureActiveDirectoryAccessTokenAuthentication"
            },
            {
              "$ref": "#/components/schemas/AzureActiveDirectoryDefaultAuthentication"
            },
            {
              "$ref": "#/components/schemas/AzureActiveDirectoryMsiAppServiceAuthentication"
            },
            {
              "$ref": "#/components/schemas/AzureActiveDirectoryMsiVmAuthentication"
            },
            {
              "$ref": "#/components/schemas/AzureActiveDirectoryPasswordAuthentication"
            },
            {
              "$ref": "#/components/schemas/AzureActiveDirectoryServicePrincipalSecret"
            }
          ]
        },
        "DefaultAuthentication": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "default"
            },
            "options": {
              "type": "object",
              "properties": {
                "userName": {
                  "type": "string",
                  "description": "User name to use for sql server login."
                },
                "password": {
                  "type": "string",
                  "description": "Password to use for sql server login."
                }
              }
            }
          },
          "required": ["type", "options"]
        },
        "NtlmAuthentication": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "ntlm"
            },
            "options": {
              "type": "object",
              "properties": {
                "userName": {
                  "type": "string",
                  "description": "User name from your windows account."
                },
                "password": {
                  "type": "string",
                  "description": "Password from your windows account."
                },
                "domain": {
                  "type": "string",
                  "description": "Once you set domain for ntlm authentication type, driver will connect to SQL Server using domain login.\n\nThis is necessary for forming a connection using ntlm type"
                }
              },
              "required": ["userName", "password", "domain"]
            }
          },
          "required": ["type", "options"]
        },
        "AzureActiveDirectoryAccessTokenAuthentication": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "azure-active-directory-access-token"
            },
            "options": {
              "type": "object",
              "properties": {
                "token": {
                  "type": "string",
                  "description": "A user need to provide `token` which they retrieved else where to forming the connection."
                }
              },
              "required": ["token"]
            }
          },
          "required": ["type", "options"]
        },
        "AzureActiveDirectoryDefaultAuthentication": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "azure-active-directory-default",
              "description": "This uses DefaultAzureCredential from"
            },
            "options": {
              "type": "object",
              "properties": {
                "clientId": {
                  "type": "string",
                  "description": "The clientId of the user you want to log in with, mapped to the managedIdentityClientId in tedious"
                }
              }
            }
          },
          "required": ["type", "options"]
        },
        "AzureActiveDirectoryMsiAppServiceAuthentication": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "azure-active-directory-msi-app-service"
            },
            "options": {
              "type": "object",
              "properties": {
                "clientId": {
                  "type": "string",
                  "description": "If you user want to connect to an Azure app service using a specific client account they need to provide `clientId` associate to their created identity.\n\nThis is optional for retrieve token from azure web app service"
                },
                "msiEndpoint": {
                  "type": "string",
                  "description": "A msi app service environment need to provide `msiEndpoint` for retriving the accesstoken."
                },
                "msiSecret": {
                  "type": "string",
                  "description": "A msi app service environment need to provide `msiSecret` for retrieved the accesstoken."
                }
              }
            }
          },
          "required": ["type", "options"]
        },
        "AzureActiveDirectoryMsiVmAuthentication": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "azure-active-directory-msi-vm"
            },
            "options": {
              "type": "object",
              "properties": {
                "clientId": {
                  "type": "string",
                  "description": "If you user want to connect to an Azure app service using a specific client account they need to provide `clientId` associate to their created identity.\n\nThis is optional for retrieve token from azure web app service"
                },
                "msiEndpoint": {
                  "type": "string",
                  "description": "A user need to provide `msiEndpoint` for retrieving the accesstoken."
                }
              }
            }
          },
          "required": ["type", "options"]
        },
        "AzureActiveDirectoryPasswordAuthentication": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "azure-active-directory-password"
            },
            "options": {
              "type": "object",
              "properties": {
                "userName": {
                  "type": "string",
                  "description": "A user need to provide `userName` associate to their account."
                },
                "password": {
                  "type": "string",
                  "description": "A user need to provide `password` associate to their account."
                },
                "domain": {
                  "type": "string",
                  "description": "Optional parameter for specific Azure tenant ID"
                }
              },
              "required": ["userName", "password", "domain"]
            }
          },
          "required": ["type", "options"]
        },
        "AzureActiveDirectoryServicePrincipalSecret": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "azure-active-directory-service-principal-secret"
            },
            "options": {
              "type": "object",
              "properties": {
                "clientId": {
                  "type": "string",
                  "description": "Application (`client`) ID from your registered Azure application"
                },
                "clientSecret": {
                  "type": "string",
                  "description": "The created `client secret` for this registered Azure application"
                },
                "tenantId": {
                  "type": "string",
                  "description": "Directory (`tenant`) ID from your registered Azure application"
                }
              },
              "required": ["clientId", "clientSecret", "tenantId"]
            }
          },
          "required": ["type", "options"]
        },
        "SqlServerConnectionCredentialsOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "authentication": {
              "$ref": "#/components/schemas/SqlServerConnectionCredentialsAuthenticationOptions",
              "description": "Authentication settings It overrides username and password, when passed."
            },
            "domain": {
              "type": "string",
              "description": "Once you set domain, driver will connect to SQL Server using domain login.",
              "deprecated": true
            }
          },
          "description": "SqlServer specific connection credential options."
        },
        "SapConnectionOptions": {
          "type": "object",
          "properties": {
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "encrypt": {
              "type": "boolean",
              "description": "Encrypt database connection"
            },
            "sslValidateCertificate": {
              "type": "boolean",
              "description": "Validate database certificate"
            },
            "key": {
              "type": "string",
              "description": "Key for encrypted connection"
            },
            "cert": {
              "type": "string",
              "description": "Cert for encrypted connection"
            },
            "ca": {
              "type": "string",
              "description": "Ca for encrypted connection"
            },
            "type": {
              "type": "string",
              "const": "sap",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "schema": {
              "type": "string",
              "description": "Database schema."
            },
            "driver": {
              "description": "The driver objects This defaults to require(\"hdb-pool\")"
            },
            "hanaClientDriver": {
              "description": "The driver objects This defaults to require(\"@sap/hana-client\")"
            },
            "pool": {
              "type": "object",
              "properties": {
                "max": {
                  "type": "number",
                  "description": "Max number of connections."
                },
                "min": {
                  "type": "number",
                  "description": "Minimum number of connections."
                },
                "maxWaitingRequests": {
                  "type": "number",
                  "description": "Maximum number of waiting requests allowed. (default=0, no limit)."
                },
                "requestTimeout": {
                  "type": "number",
                  "description": "Max milliseconds a request will wait for a resource before timing out. (default=5000)"
                },
                "checkInterval": {
                  "type": "number",
                  "description": "How often to run resource timeout checks. (default=0, disabled)"
                },
                "idleTimeout": {
                  "type": "number",
                  "description": "Idle timeout"
                },
                "poolErrorHandler": {
                  "$comment": "(err: any) => any",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "err": {}
                      },
                      "required": ["err"],
                      "additionalProperties": false
                    }
                  },
                  "description": "Function handling errors thrown by drivers pool. Defaults to logging error with `warn` level."
                }
              },
              "description": "Pool options."
            }
          },
          "required": ["type"],
          "description": "SAP Hana specific connection options."
        },
        "OracleConnectionOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "sid": {
              "type": "string",
              "description": "Connection SID."
            },
            "serviceName": {
              "type": "string",
              "description": "Connection Service Name."
            },
            "connectString": {
              "type": "string",
              "description": "Embedded TNS Connection String"
            },
            "type": {
              "type": "string",
              "const": "oracle",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "type": "number",
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "schema": {
              "type": "string",
              "description": "Schema name. By default is \"public\"."
            },
            "driver": {
              "description": "The driver object This defaults to require(\"oracledb\")"
            },
            "thickMode": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "$ref": "#/components/schemas/OracleThickModeOptions"
                }
              ],
              "description": "Utilize the thick driver. Starting from oracledb version 6, it's necessary to set this to true when opting for the thick client usage. Alternatively, an 'OracleThickModeOptions' object can be configured, which is used for the thick mode configuration by passing it to the 'node-oracledb' driver. For additional information, refer to the details provided in the following link: (https://node-oracledb.readthedocs.io/en/latest/api_manual/oracledb.html#oracledb.initOracleClient)"
            },
            "useUTC": {
              "type": "boolean",
              "description": "A boolean determining whether to pass time values in UTC or local time. (default: false)."
            },
            "replication": {
              "type": "object",
              "properties": {
                "master": {
                  "$ref": "#/components/schemas/OracleConnectionCredentialsOptions",
                  "description": "Master server used by orm to perform writes."
                },
                "slaves": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/OracleConnectionCredentialsOptions"
                  },
                  "description": "List of read-from servers (slaves)."
                }
              },
              "required": ["master", "slaves"],
              "description": "Replication setup."
            }
          },
          "required": ["type"],
          "description": "Oracle-specific connection options."
        },
        "OracleThickModeOptions": {
          "type": "object",
          "properties": {
            "binaryDir": {
              "type": "string"
            },
            "configDir": {
              "type": "string"
            },
            "driverName": {
              "type": "string"
            },
            "errorUrl": {
              "type": "string"
            },
            "libDir": {
              "type": "string"
            }
          }
        },
        "OracleConnectionCredentialsOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "sid": {
              "type": "string",
              "description": "Connection SID."
            },
            "serviceName": {
              "type": "string",
              "description": "Connection Service Name."
            },
            "connectString": {
              "type": "string",
              "description": "Embedded TNS Connection String"
            }
          },
          "description": "Oracle specific connection credential options."
        },
        "CordovaConnectionOptions": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "cordova",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "database": {
              "type": "string",
              "description": "Database name."
            },
            "driver": {
              "description": "The driver object This defaults to `window.sqlitePlugin`"
            },
            "location": {
              "type": "string",
              "description": "Storage Location"
            }
          },
          "required": ["database", "location", "type"],
          "description": "Sqlite-specific connection options."
        },
        "NativescriptConnectionOptions": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "nativescript",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "database": {
              "type": "string",
              "description": "Database name."
            },
            "driver": {
              "description": "The driver object you should pass `require('nativescript-sqlite') here"
            },
            "readOnly": {
              "type": "boolean",
              "description": "Whether to mark the mark the database as read only on open (iOS only)."
            },
            "key": {
              "type": "string",
              "description": "The key to use for for using/opening encrypted databases. (requires the \"Encrypted Plugin\")"
            },
            "multithreading": {
              "type": "boolean",
              "description": "Whether to enable background multitasking. All SQL is ran on a background worker thread. (requires the \"Commercial Plugin\")"
            },
            "migrate": {
              "type": "boolean",
              "description": "Migrates a Encrypted Sql database from v3 to the new v4. If you are a new user you do not need to set this flag as new created databases will already be in v4. If you are upgrading a app that used v1.3.0 or earlier of NS-Sqlite-Encrypted; then you will probably want to set this flag to true. (requires the \"Encrypted Plugin\")"
            },
            "iosFlags": {
              "type": "number",
              "description": "Flags to pass to SQLite when opening the database on iOS. (see https://www.sqlite.org/c3ref/open.html)"
            },
            "androidFlags": {
              "type": "number",
              "description": "Flags to pass to SQLite when opening the database on Android. (see https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html)"
            }
          },
          "required": ["database", "driver", "type"],
          "description": "NativeScript-specific connection options."
        },
        "ReactNativeConnectionOptions": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "react-native",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "database": {
              "type": "string",
              "description": "Database name."
            },
            "driver": {
              "description": "The driver object This defaults to require(\"react-native-sqlite-storage\")"
            },
            "location": {
              "type": "string",
              "description": "Storage Location"
            }
          },
          "required": ["database", "location", "type"],
          "description": "Sqlite-specific connection options."
        },
        "SqljsConnectionOptions": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "sqljs",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "database": {
              "type": "object",
              "properties": {
                "BYTES_PER_ELEMENT": {
                  "type": "number"
                },
                "buffer": {
                  "anyOf": [
                    {
                      "type": "object",
                      "properties": {
                        "byteLength": {
                          "type": "number"
                        }
                      },
                      "required": ["byteLength"]
                    },
                    {}
                  ]
                },
                "byteLength": {
                  "type": "number"
                },
                "byteOffset": {
                  "type": "number"
                },
                "length": {
                  "type": "number"
                }
              },
              "required": ["BYTES_PER_ELEMENT", "buffer", "byteLength", "byteOffset", "length"],
              "additionalProperties": {
                "type": "number"
              },
              "description": "A Uint8Array that gets imported when the connection is opened."
            },
            "driver": {
              "description": "The driver object This defaults to require(\"sql.js\")"
            },
            "sqlJsConfig": {
              "description": "Config that's used to initialize sql.js."
            },
            "autoSave": {
              "type": "boolean",
              "description": "Enables the autoSave mechanism which either saves to location or calls autoSaveCallback every time a change to the database is made."
            },
            "autoSaveCallback": {
              "type": "object",
              "properties": {
                "prototype": {},
                "length": {
                  "type": "number"
                },
                "arguments": {},
                "caller": {
                  "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                }
              },
              "required": ["prototype", "length", "arguments", "caller"],
              "description": "A function that gets called on every change instead of the internal autoSave function. autoSave has to be enabled for this to work."
            },
            "location": {
              "type": "string",
              "description": "File path (Node.js) or local storage key (browser) to load and save database from. If this is specified without autoSave, the database is loaded from the location and can be saved manually via the SqljsEntityManager. If autoSave is enabled, location is used to automatically save the database."
            },
            "useLocalForage": {
              "type": "boolean",
              "description": "Enables the usage of the localforage library to save & load the database asynchronously from the indexedDB instead of using the synchron local storage methods in a browser environment."
            }
          },
          "required": ["type"],
          "description": "Sql.js-specific connection options."
        },
        "MongoConnectionOptions": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "mongodb",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "type": "number",
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "hostReplicaSet": {
              "type": "string",
              "description": "Database host replica set."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "directConnection": {
              "type": "boolean",
              "description": "Specifies whether to force dispatch all operations to the specified host. Default: false"
            },
            "driver": {
              "description": "The driver object This defaults to require(\"mongodb\")"
            },
            "ssl": {
              "type": "boolean",
              "description": "Use ssl connection (needs to have a mongod server with ssl support). Default: false"
            },
            "sslValidate": {
              "type": "boolean",
              "description": "Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher). Default: true"
            },
            "sslCA": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                }
              ],
              "description": "Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)."
            },
            "sslCert": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                }
              ],
              "description": "String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)"
            },
            "sslKey": {
              "type": "string",
              "description": "String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)"
            },
            "sslPass": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                }
              ],
              "description": "String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)"
            },
            "sslCRL": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/global.Buffer"
                }
              ],
              "description": "SSL Certificate revocation list binary buffer (needs to have a mongod server with ssl support, 2.4 or higher)"
            },
            "autoReconnect": {
              "type": "boolean",
              "description": "Reconnect on error. Default: true"
            },
            "noDelay": {
              "type": "boolean",
              "description": "TCP Socket NoDelay option. Default: true"
            },
            "keepAlive": {
              "type": "number",
              "description": "The number of milliseconds to wait before initiating keepAlive on the TCP socket. Default: 30000"
            },
            "connectTimeoutMS": {
              "type": "number",
              "description": "TCP Connection timeout setting. Default: 30000"
            },
            "family": {
              "type": "number",
              "description": "Version of IP stack. Can be 4, 6. If undefined, will attempt to connect with IPv6, and will fall back to IPv4 on failure"
            },
            "socketTimeoutMS": {
              "type": "number",
              "description": "TCP Socket timeout setting. Default: 360000"
            },
            "reconnectTries": {
              "type": "number",
              "description": "Server attempt to reconnect #times. Default 30"
            },
            "reconnectInterval": {
              "type": "number",
              "description": "Server will wait #milliseconds between retries. Default 1000"
            },
            "ha": {
              "type": "boolean",
              "description": "Control if high availability monitoring runs for Replicaset or Mongos proxies. Default true"
            },
            "haInterval": {
              "type": "number",
              "description": "The High availability period for replicaset inquiry. Default: 10000"
            },
            "replicaSet": {
              "type": "string",
              "description": "The name of the replicaset to connect to"
            },
            "acceptableLatencyMS": {
              "type": "number",
              "description": "Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms). Default: 15"
            },
            "secondaryAcceptableLatencyMS": {
              "type": "number",
              "description": "Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms). Default: 15"
            },
            "connectWithNoPrimary": {
              "type": "boolean",
              "description": "Sets if the driver should connect even if no primary is available. Default: false"
            },
            "authSource": {
              "type": "string",
              "description": "If the database authentication is dependent on another databaseName."
            },
            "w": {
              "type": ["string", "number"],
              "description": "The write concern."
            },
            "wtimeout": {
              "type": "number",
              "description": "The write concern timeout value."
            },
            "j": {
              "type": "boolean",
              "description": "Specify a journal write concern. Default: false"
            },
            "forceServerObjectId": {
              "type": "boolean",
              "description": "Force server to assign _id values instead of driver. Default: false"
            },
            "serializeFunctions": {
              "type": "boolean",
              "description": "Serialize functions on any object. Default: false"
            },
            "ignoreUndefined": {
              "type": "boolean",
              "description": "Specify if the BSON serializer should ignore undefined fields. Default: false"
            },
            "raw": {
              "type": "boolean",
              "description": "Return document results as raw BSON buffers. Default: false"
            },
            "promoteLongs": {
              "type": "boolean",
              "description": "Promotes Long values to number if they fit inside the 53 bits resolution. Default: true"
            },
            "promoteBuffers": {
              "type": "boolean",
              "description": "Promotes Binary BSON values to native Node Buffers. Default: false"
            },
            "promoteValues": {
              "type": "boolean",
              "description": "Promotes BSON values to native types where possible, set to false to only receive wrapper types. Default: true"
            },
            "domainsEnabled": {
              "type": "boolean",
              "description": "Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit. Default: false"
            },
            "bufferMaxEntries": {
              "type": "number",
              "description": "Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited."
            },
            "readPreference": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ReadPreference"
                },
                {
                  "type": "string"
                }
              ],
              "description": "The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST)."
            },
            "pkFactory": {
              "description": "A primary key factory object for generation of custom _id keys."
            },
            "promiseLibrary": {
              "description": "A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible."
            },
            "readConcern": {
              "description": "Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)."
            },
            "maxStalenessSeconds": {
              "type": "number",
              "description": "Specify a maxStalenessSeconds value for secondary reads, minimum is 90 seconds"
            },
            "loggerLevel": {
              "type": "string",
              "enum": ["error", "warn", "info", "debug"],
              "description": "Specify the log level used by the driver logger (error/warn/info/debug)."
            },
            "checkServerIdentity": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                }
              ],
              "description": "Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function Default: true"
            },
            "validateOptions": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {}
              ],
              "description": "Validate MongoClient passed in options for correctness. Default: false"
            },
            "appname": {
              "type": "string",
              "description": "The name of the application that created this MongoClient instance. MongoDB 3.4 and newer will print this value in the server log upon establishing each connection. It is also recorded in the slow query log and profile collections"
            },
            "authMechanism": {
              "type": "string",
              "description": "Sets the authentication mechanism that MongoDB will use to authenticate the connection"
            },
            "compression": {
              "description": "Type of compression to use: snappy or zlib"
            },
            "fsync": {
              "type": "boolean",
              "description": "Specify a file sync write concern. Default: false"
            },
            "readPreferenceTags": {
              "type": "array",
              "items": {},
              "description": "Read preference tags"
            },
            "numberOfRetries": {
              "type": "number",
              "description": "The number of retries for a tailable cursor. Default: 5"
            },
            "auto_reconnect": {
              "type": "boolean",
              "description": "Enable auto reconnecting for single server instances. Default: true"
            },
            "monitorCommands": {
              "type": "boolean",
              "description": "Enable command monitoring for this client. Default: false"
            },
            "minSize": {
              "type": "number",
              "description": "If present, the connection pool will be initialized with minSize connections, and will never dip below minSize connections"
            },
            "useNewUrlParser": {
              "type": "boolean",
              "description": "Determines whether or not to use the new url parser. Default: false"
            },
            "useUnifiedTopology": {
              "type": "boolean",
              "description": "Determines whether or not to use the new Server Discovery and Monitoring engine. Default: false https://github.com/mongodb/node-mongodb-native/releases/tag/v3.2.1"
            },
            "autoEncryption": {
              "description": "Automatic Client-Side Field Level Encryption configuration."
            },
            "retryWrites": {
              "type": "boolean",
              "description": "Enables or disables the ability to retry writes upon encountering transient network errors."
            }
          },
          "required": ["type"],
          "description": "MongoDB specific connection options. Synced with http://mongodb.github.io/node-mongodb-native/3.1/api/MongoClient.html"
        },
        "ReadPreference": {
          "type": "object",
          "properties": {
            "mode": {
              "$ref": "#/components/schemas/ReadPreferenceMode"
            },
            "tags": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TagSet"
              }
            },
            "hedge": {
              "$ref": "#/components/schemas/HedgeOptions"
            },
            "maxStalenessSeconds": {
              "type": "number"
            },
            "minWireVersion": {
              "type": "number"
            }
          },
          "required": ["mode"],
          "description": "The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is used to construct connections."
        },
        "ReadPreferenceMode": {
          "anyOf": [
            {
              "type": "string",
              "const": "primary"
            },
            {
              "type": "string",
              "const": "primaryPreferred"
            },
            {
              "type": "string",
              "const": "secondary"
            },
            {
              "type": "string",
              "const": "secondaryPreferred"
            },
            {
              "type": "string",
              "const": "nearest"
            },
            {}
          ]
        },
        "TagSet": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "HedgeOptions": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Explicitly enable or disable hedged reads."
            }
          }
        },
        "AuroraMysqlConnectionOptions": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "host": {
              "type": "string",
              "description": "Database host."
            },
            "port": {
              "type": "number",
              "description": "Database host port."
            },
            "username": {
              "type": "string",
              "description": "Database username."
            },
            "password": {
              "type": "string",
              "description": "Database password."
            },
            "database": {
              "type": "string",
              "description": "Database name to connect to."
            },
            "ssl": {
              "description": "Object with ssl parameters or a string containing name of ssl profile."
            },
            "type": {
              "type": "string",
              "const": "aurora-mysql",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "region": {
              "type": "string"
            },
            "secretArn": {
              "type": "string"
            },
            "resourceArn": {
              "type": "string"
            },
            "driver": {
              "description": "The driver object This defaults to require(\"typeorm-aurora-data-api-driver\")"
            },
            "serviceConfigOptions": {
              "type": "object"
            },
            "formatOptions": {
              "type": "object",
              "properties": {
                "castParameters": {
                  "type": "boolean"
                }
              },
              "required": ["castParameters"]
            },
            "legacySpatialSupport": {
              "type": "boolean",
              "description": "Use spatial functions like GeomFromText and AsText which are removed in MySQL 8. (Default: true)"
            }
          },
          "required": ["database", "region", "resourceArn", "secretArn", "type"],
          "description": "MySQL specific connection options."
        },
        "AuroraPostgresConnectionOptions": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "aurora-postgres",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "region": {
              "type": "string"
            },
            "secretArn": {
              "type": "string"
            },
            "resourceArn": {
              "type": "string"
            },
            "database": {
              "type": "string"
            },
            "driver": {
              "description": "The driver object This defaults to require(\"typeorm-aurora-data-api-driver\")"
            },
            "uuidExtension": {
              "type": "string",
              "enum": ["pgcrypto", "uuid-ossp"],
              "description": "The Postgres extension to use to generate UUID columns. Defaults to uuid-ossp. If pgcrypto is selected, TypeORM will use the gen_random_uuid() function from this extension. If uuid-ossp is selected, TypeORM will use the uuid_generate_v4() function from this extension."
            },
            "transformParameters": {
              "type": "boolean"
            },
            "poolErrorHandler": {
              "$comment": "(err: any) => any",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "err": {}
                  },
                  "required": ["err"],
                  "additionalProperties": false
                }
              }
            },
            "serviceConfigOptions": {
              "type": "object"
            },
            "formatOptions": {
              "type": "object",
              "properties": {
                "castParameters": {
                  "type": "boolean"
                }
              },
              "required": ["castParameters"]
            }
          },
          "required": ["database", "region", "resourceArn", "secretArn", "type"],
          "description": "Postgres-specific connection options."
        },
        "ExpoConnectionOptions": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "expo",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "database": {
              "type": "string",
              "description": "Database name."
            },
            "driver": {
              "description": "Driver module"
            }
          },
          "required": ["database", "driver", "type"],
          "description": "Sqlite-specific connection options."
        },
        "BetterSqlite3ConnectionOptions": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "better-sqlite3",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "database": {
              "type": "string",
              "description": "Storage type or path to the storage."
            },
            "driver": {
              "description": "The driver object This defaults to require(\"better-sqlite3\")"
            },
            "key": {
              "type": "string",
              "description": "Encryption key for for SQLCipher."
            },
            "statementCacheSize": {
              "type": "number",
              "description": "Cache size of sqlite statement to speed up queries. Default: 100."
            },
            "prepareDatabase": {
              "$comment": "(db: any) => void | Promise<void>",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "db": {}
                  },
                  "required": ["db"],
                  "additionalProperties": false
                }
              },
              "description": "Function to run before a database is used in typeorm. You can set pragmas, register plugins or register functions or aggregates in this function."
            },
            "readonly": {
              "type": "boolean",
              "description": "Open the database connection in readonly mode. Default: false."
            },
            "fileMustExist": {
              "type": "boolean",
              "description": "If the database does not exist, an Error will be thrown instead of creating a new file. This option does not affect in-memory or readonly database connections. Default: false."
            },
            "timeout": {
              "type": "number",
              "description": "The number of milliseconds to wait when executing queries on a locked database, before throwing a SQLITE_BUSY error. Default: 5000."
            },
            "verbose": {
              "type": "object",
              "properties": {
                "prototype": {},
                "length": {
                  "type": "number"
                },
                "arguments": {},
                "caller": {
                  "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                }
              },
              "required": ["prototype", "length", "arguments", "caller"],
              "description": "Provide a function that gets called with every SQL string executed by the database connection."
            },
            "nativeBinding": {
              "type": "string",
              "description": "Relative or absolute path to the native addon (better_sqlite3.node)."
            },
            "enableWAL": {
              "type": "boolean",
              "description": "Enables WAL mode. By default its disabled."
            }
          },
          "required": ["database", "type"],
          "description": "Sqlite-specific connection options."
        },
        "CapacitorConnectionOptions": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "const": "capacitor",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "driver": {
              "description": "The capacitor-sqlite instance. For example, `new SQLiteConnection(CapacitorSQLite)`."
            },
            "database": {
              "type": "string",
              "description": "Database name (capacitor-sqlite will add the suffix `SQLite.db`)"
            },
            "mode": {
              "type": "string",
              "enum": ["no-encryption", "encryption", "secret", "newsecret"],
              "description": "Set the mode for database encryption"
            },
            "version": {
              "type": "number",
              "description": "Database version"
            },
            "journalMode": {
              "type": "string",
              "enum": ["DELETE", "TRUNCATE", "PERSIST", "MEMORY", "WAL", "OFF"],
              "description": "The SQLite journal mode (optional)"
            }
          },
          "required": ["database", "driver", "type"],
          "description": "Sqlite-specific connection options."
        },
        "SpannerConnectionOptions": {
          "type": "object",
          "properties": {
            "instanceId": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "projectId": {
              "type": "string",
              "description": "Database host."
            },
            "databaseId": {
              "type": "string",
              "description": "Database host port."
            },
            "type": {
              "type": "string",
              "const": "spanner",
              "description": "Database type."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "not": {},
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            },
            "driver": {
              "description": "The driver object This defaults to require(\"@google-cloud/spanner\")."
            },
            "database": {
              "type": "string"
            },
            "schema": {
              "type": "string"
            },
            "charset": {
              "type": "string",
              "description": "The charset for the connection. This is called \"collation\" in the SQL-level of MySQL (like utf8_general_ci). If a SQL-level charset is specified (like utf8mb4) then the default collation for that charset is used. Default: 'UTF8_GENERAL_CI'"
            },
            "timezone": {
              "type": "string",
              "description": "The timezone configured on the MySQL server. This is used to type cast server date/time values to JavaScript Date object and vice versa. This can be 'local', 'Z', or an offset in the form +HH:MM or -HH:MM. (Default: 'local')"
            },
            "connectTimeout": {
              "type": "number",
              "description": "The milliseconds before a timeout occurs during the initial connection to the MySQL server. (Default: 10000)"
            },
            "acquireTimeout": {
              "type": "number",
              "description": "The milliseconds before a timeout occurs during the initial connection to the MySQL server. (Default: 10000) This difference between connectTimeout and acquireTimeout is subtle and is described in the mysqljs/mysql docs https://github.com/mysqljs/mysql/tree/master#pool-options"
            },
            "insecureAuth": {
              "type": "boolean",
              "description": "Allow connecting to MySQL instances that ask for the old (insecure) authentication method. (Default: false)"
            },
            "supportBigNumbers": {
              "type": "boolean",
              "description": "When dealing with big numbers (BIGINT and DECIMAL columns) in the database, you should enable this option (Default: false)"
            },
            "bigNumberStrings": {
              "type": "boolean",
              "description": "Enabling both supportBigNumbers and bigNumberStrings forces big numbers (BIGINT and DECIMAL columns) to be always returned as JavaScript String objects (Default: false). Enabling supportBigNumbers but leaving bigNumberStrings disabled will return big numbers as String objects only when they cannot be accurately represented with [JavaScript Number objects](http://ecma262-5.com/ELS5_HTML.htm#Section_8.5) (which happens when they exceed the [-2^53, +2^53] range), otherwise they will be returned as Number objects. This option is ignored if supportBigNumbers is disabled."
            },
            "dateStrings": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Force date types (TIMESTAMP, DATETIME, DATE) to be returned as strings rather then inflated into JavaScript Date objects. Can be true/false or an array of type names to keep as strings."
            },
            "debug": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Prints protocol details to stdout. Can be true/false or an array of packet type names that should be printed. (Default: false)"
            },
            "trace": {
              "type": "boolean",
              "description": "Generates stack traces on Error to include call site of library entrance (\"long stack traces\"). Slight performance penalty for most calls. (Default: true)"
            },
            "multipleStatements": {
              "type": "boolean",
              "description": "Allow multiple mysql statements per query. Be careful with this, it could increase the scope of SQL injection attacks. (Default: false)"
            },
            "legacySpatialSupport": {
              "type": "boolean",
              "description": "Use spatial functions like GeomFromText and AsText which are removed in MySQL 8. (Default: true)"
            },
            "flags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of connection flags to use other than the default ones. It is also possible to blacklist default ones. For more information, check https://github.com/mysqljs/mysql#connection-flags."
            },
            "replication": {
              "type": "object",
              "properties": {
                "master": {
                  "$ref": "#/components/schemas/SpannerConnectionCredentialsOptions",
                  "description": "Master server used by orm to perform writes."
                },
                "slaves": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SpannerConnectionCredentialsOptions"
                  },
                  "description": "List of read-from servers (slaves)."
                },
                "canRetry": {
                  "type": "boolean",
                  "description": "If true, PoolCluster will attempt to reconnect when connection fails. (Default: true)"
                },
                "removeNodeErrorCount": {
                  "type": "number",
                  "description": "If connection fails, node's errorCount increases. When errorCount is greater than removeNodeErrorCount, remove a node in the PoolCluster. (Default: 5)"
                },
                "restoreNodeTimeout": {
                  "type": "number",
                  "description": "If connection fails, specifies the number of milliseconds before another connection attempt will be made. If set to 0, then node will be removed instead and never re-used. (Default: 0)"
                },
                "selector": {
                  "type": "string",
                  "enum": ["RR", "RANDOM", "ORDER"],
                  "description": "Determines how slaves are selected: RR: Select one alternately (Round-Robin). RANDOM: Select the node by random function. ORDER: Select the first node available unconditionally."
                },
                "defaultMode": {
                  "$ref": "#/components/schemas/ReplicationMode",
                  "description": "Default connection pool to use for SELECT queries",
                  "default": "slave"
                }
              },
              "required": ["master", "slaves"],
              "description": "Replication setup."
            }
          },
          "required": ["type"],
          "description": "Spanner specific connection options."
        },
        "SpannerConnectionCredentialsOptions": {
          "type": "object",
          "properties": {
            "instanceId": {
              "type": "string",
              "description": "Connection url where the connection is performed."
            },
            "projectId": {
              "type": "string",
              "description": "Database host."
            },
            "databaseId": {
              "type": "string",
              "description": "Database host port."
            }
          },
          "description": "Spanner specific connection credential options."
        },
        "Driver": {
          "type": "object",
          "properties": {
            "options": {
              "$ref": "#/components/schemas/BaseDataSourceOptions",
              "description": "Connection options."
            },
            "version": {
              "type": "string",
              "description": "Database version/release. Often requires a SQL query to the DB, so it is not always set"
            },
            "database": {
              "type": "string",
              "description": "Database name used to perform all write queries.\n\ntodo: probably move into query runner."
            },
            "schema": {
              "type": "string",
              "description": "Schema name used to perform all write queries."
            },
            "isReplicated": {
              "type": "boolean",
              "description": "Indicates if replication is enabled."
            },
            "treeSupport": {
              "type": "boolean",
              "description": "Indicates if tree tables are supported by this driver."
            },
            "transactionSupport": {
              "type": "string",
              "enum": ["simple", "nested", "none"],
              "description": "Represent transaction support by this driver"
            },
            "supportedDataTypes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnType"
              },
              "description": "Gets list of supported column data types by a driver."
            },
            "supportedUpsertTypes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/UpsertType"
              },
              "description": "Returns type of upsert supported by driver if any"
            },
            "supportedOnDeleteTypes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/OnDeleteType"
              },
              "description": "Returns list of supported onDelete types by driver"
            },
            "supportedOnUpdateTypes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/OnUpdateType"
              },
              "description": "Returns list of supported onUpdate types by driver"
            },
            "dataTypeDefaults": {
              "$ref": "#/components/schemas/DataTypeDefaults",
              "description": "Default values of length, precision and scale depends on column data type. Used in the cases when length/precision/scale is not specified by user."
            },
            "spatialTypes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnType"
              },
              "description": "Gets list of spatial column data types."
            },
            "withLengthColumnTypes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnType"
              },
              "description": "Gets list of column data types that support length by a driver."
            },
            "withPrecisionColumnTypes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnType"
              },
              "description": "Gets list of column data types that support precision by a driver."
            },
            "withScaleColumnTypes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnType"
              },
              "description": "Gets list of column data types that support scale by a driver."
            },
            "mappedDataTypes": {
              "$ref": "#/components/schemas/MappedColumnTypes",
              "description": "Orm has special columns and we need to know what database column types should be for those types. Column types are driver dependant."
            },
            "parametersPrefix": {
              "type": "string",
              "description": "The prefix used for the parameters"
            },
            "maxAliasLength": {
              "type": "number",
              "description": "Max length allowed by the DBMS for aliases (execution of queries)."
            },
            "cteCapabilities": {
              "$ref": "#/components/schemas/CteCapabilities"
            },
            "dummyTableName": {
              "type": "string",
              "description": "Dummy table name"
            }
          },
          "required": [
            "options",
            "isReplicated",
            "treeSupport",
            "transactionSupport",
            "supportedDataTypes",
            "supportedUpsertTypes",
            "dataTypeDefaults",
            "spatialTypes",
            "withLengthColumnTypes",
            "withPrecisionColumnTypes",
            "withScaleColumnTypes",
            "mappedDataTypes",
            "cteCapabilities"
          ],
          "description": "Driver organizes TypeORM communication with specific database management system."
        },
        "BaseDataSourceOptions": {
          "type": "object",
          "properties": {
            "type": {
              "$ref": "#/components/schemas/DatabaseType",
              "description": "Database type. This value is required."
            },
            "name": {
              "type": "string",
              "description": "Connection name. If connection name is not given then it will be called \"default\". Different connections must have different names.",
              "deprecated": true
            },
            "entities": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string|EntitySchema)>",
              "description": "Entities to be loaded for this connection. Accepts both entity classes and directories where from entities need to be loaded. Directories support glob patterns."
            },
            "subscribers": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Subscribers to be loaded for this connection. Accepts both subscriber classes and directories where from subscribers need to be loaded. Directories support glob patterns."
            },
            "migrations": {
              "$ref": "#/components/schemas/MixedList<(interface-1506616821-9888-11315-1506616821-0-215038|string)>",
              "description": "Migrations to be loaded for this connection. Accepts both migration classes and glob patterns representing migration files."
            },
            "migrationsTableName": {
              "type": "string",
              "description": "Migrations table name, in case of different name from \"migrations\". Accepts single string name."
            },
            "migrationsTransactionMode": {
              "type": "string",
              "enum": ["all", "none", "each"],
              "description": "Transaction mode for migrations to run in"
            },
            "metadataTableName": {
              "type": "string",
              "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\". Accepts single string name."
            },
            "namingStrategy": {
              "$ref": "#/components/schemas/NamingStrategyInterface",
              "description": "Naming strategy to be used to name tables and columns in the database."
            },
            "logging": {
              "$ref": "#/components/schemas/LoggerOptions",
              "description": "Logging options."
            },
            "logger": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "advanced-console"
                },
                {
                  "type": "string",
                  "const": "simple-console"
                },
                {
                  "type": "string",
                  "const": "file"
                },
                {
                  "type": "string",
                  "const": "debug"
                },
                {
                  "$ref": "#/components/schemas/Logger"
                }
              ],
              "description": "Logger instance used to log queries and events in the ORM."
            },
            "maxQueryExecutionTime": {
              "type": "number",
              "description": "Maximum number of milliseconds query should be executed before logger log a warning."
            },
            "poolSize": {
              "type": "number",
              "description": "Maximum number of clients the pool should contain."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if database schema should be auto created on every application launch. Be careful with this option and don't use this in production - otherwise you can lose production data. This option is useful during debug and development. Alternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless. Instead, it syncs just by creating indices."
            },
            "migrationsRun": {
              "type": "boolean",
              "description": "Indicates if migrations should be auto run on every application launch. Alternative to it, you can use CLI and run migrations:run command."
            },
            "dropSchema": {
              "type": "boolean",
              "description": "Drops the schema each time connection is being established. Be careful with this option and don't use this in production - otherwise you'll lose all production data. This option is useful during debug and development."
            },
            "entityPrefix": {
              "type": "string",
              "description": "Prefix to use on all tables (collections) of this connection in the database."
            },
            "entitySkipConstructor": {
              "type": "boolean",
              "description": "When creating new Entity instances, skip all constructors when true."
            },
            "extra": {
              "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
            },
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Specifies how relations must be loaded - using \"joins\" or separate queries. If you are loading too much data with nested joins it's better to load relations using separate queries.\n\nDefault strategy is \"join\", but this default can be changed here. Also, strategy can be set per-query in FindOptions and QueryBuilder."
            },
            "typename": {
              "type": "string",
              "description": "Optionally applied \"typename\" to the model. If set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property)."
            },
            "cache": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["database", "redis", "ioredis", "ioredis/cluster"],
                      "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options."
                    },
                    "provider": {
                      "$comment": "(connection: DataSource) => QueryResultCache",
                      "type": "object",
                      "properties": {
                        "namedArgs": {
                          "type": "object",
                          "properties": {
                            "connection": {
                              "$ref": "#/components/schemas/DataSource"
                            }
                          },
                          "required": ["connection"],
                          "additionalProperties": false
                        }
                      },
                      "description": "Factory function for custom cache providers that implement QueryResultCache."
                    },
                    "tableName": {
                      "type": "string",
                      "description": "Configurable table name for \"database\" type cache. Default value is \"query-result-cache\""
                    },
                    "options": {
                      "description": "Used to provide redis connection options."
                    },
                    "alwaysEnabled": {
                      "type": "boolean",
                      "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached."
                    },
                    "duration": {
                      "type": "number",
                      "description": "Time in milliseconds in which cache will expire. This can be setup per-query. Default value is 1000 which is equivalent to 1 second."
                    },
                    "ignoreErrors": {
                      "type": "boolean",
                      "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database."
                    }
                  }
                }
              ],
              "description": "Allows to setup cache options."
            },
            "isolateWhereStatements": {
              "type": "boolean",
              "description": "Allows automatic isolation of where clauses"
            }
          },
          "required": ["type"],
          "description": "BaseDataSourceOptions is set of DataSourceOptions shared by all database types."
        },
        "DatabaseType": {
          "type": "string",
          "enum": [
            "mysql",
            "postgres",
            "cockroachdb",
            "sap",
            "mariadb",
            "sqlite",
            "cordova",
            "react-native",
            "nativescript",
            "sqljs",
            "oracle",
            "mssql",
            "mongodb",
            "aurora-mysql",
            "aurora-postgres",
            "expo",
            "better-sqlite3",
            "capacitor",
            "spanner"
          ],
          "description": "Database type."
        },
        "UpsertType": {
          "type": "string",
          "enum": ["on-conflict-do-update", "on-duplicate-key-update", "primary-key"]
        },
        "OnDeleteType": {
          "type": "string",
          "enum": ["RESTRICT", "CASCADE", "SET NULL", "DEFAULT", "NO ACTION"],
          "description": "ON_DELETE type to be used to specify delete strategy when some relation is being deleted from the database."
        },
        "OnUpdateType": {
          "type": "string",
          "enum": ["RESTRICT", "CASCADE", "SET NULL", "DEFAULT", "NO ACTION"],
          "description": "ON_UPDATE type to be used to specify update strategy when some relation is being updated."
        },
        "DataTypeDefaults": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "length": {
                "type": "number"
              },
              "width": {
                "type": "number"
              },
              "precision": {
                "type": "number"
              },
              "scale": {
                "type": "number"
              }
            }
          }
        },
        "MappedColumnTypes": {
          "type": "object",
          "properties": {
            "createDate": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for the create date column."
            },
            "createDatePrecision": {
              "type": "number",
              "description": "Precision of datetime column. Used in MySql to define milliseconds."
            },
            "createDateDefault": {
              "type": "string",
              "description": "Default value should be used by a database for \"created date\" column."
            },
            "updateDate": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for the update date column."
            },
            "updateDatePrecision": {
              "type": "number",
              "description": "Precision of datetime column. Used in MySql to define milliseconds."
            },
            "updateDateDefault": {
              "type": "string",
              "description": "Default value should be used by a database for \"updated date\" column."
            },
            "deleteDate": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for the delete date column."
            },
            "deleteDatePrecision": {
              "type": "number",
              "description": "Precision of datetime column. Used in MySql to define milliseconds."
            },
            "deleteDateNullable": {
              "type": "boolean",
              "description": "Nullable value should be used by a database for \"deleted date\" column."
            },
            "version": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for the version column."
            },
            "treeLevel": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for the tree level column."
            },
            "migrationId": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type of id column used for migrations table."
            },
            "migrationTimestamp": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type of timestamp column used for migrations table."
            },
            "migrationName": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for migration name column used for migrations table."
            },
            "cacheId": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for identifier column in query result cache table."
            },
            "cacheIdentifier": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for identifier column in query result cache table."
            },
            "cacheTime": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for time column in query result cache table."
            },
            "cacheDuration": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for duration column in query result cache table."
            },
            "cacheQuery": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for query column in query result cache table."
            },
            "cacheResult": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for result column in query result cache table."
            },
            "metadataType": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for metadata type column in typeorm metadata table. Stores type of metadata. E.g. 'VIEW' or 'CHECK'"
            },
            "metadataDatabase": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for metadata database name column in typeorm metadata table."
            },
            "metadataSchema": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for metadata schema name column in typeorm metadata table."
            },
            "metadataTable": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for metadata table name column in typeorm metadata table."
            },
            "metadataName": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for metadata name column in typeorm metadata table."
            },
            "metadataValue": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "Column type for metadata value column in typeorm metadata table."
            }
          },
          "required": [
            "createDate",
            "createDateDefault",
            "updateDate",
            "updateDateDefault",
            "deleteDate",
            "deleteDateNullable",
            "version",
            "treeLevel",
            "migrationId",
            "migrationTimestamp",
            "migrationName",
            "cacheId",
            "cacheIdentifier",
            "cacheTime",
            "cacheDuration",
            "cacheQuery",
            "cacheResult",
            "metadataType",
            "metadataDatabase",
            "metadataSchema",
            "metadataTable",
            "metadataName",
            "metadataValue"
          ],
          "description": "Orm has special columns and we need to know what database column types should be for those types. Column types are driver dependant."
        },
        "CteCapabilities": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Are CTEs supported at all?"
            },
            "writable": {
              "type": "boolean",
              "description": "Are RETURNING clauses supported in CTEs?"
            },
            "requiresRecursiveHint": {
              "type": "boolean",
              "description": "Is RECURSIVE clause required for recursive CTEs?"
            },
            "materializedHint": {
              "type": "boolean",
              "description": "Is MATERIALIZED clause supported?"
            }
          },
          "required": ["enabled"]
        },
        "EntityManager": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "connection": {
              "$ref": "#/components/schemas/DataSource",
              "description": "Connection used by this entity manager."
            },
            "queryRunner": {
              "$ref": "#/components/schemas/QueryRunner",
              "description": "Custom query runner to be used for operations in this entity manager. Used only in non-global entity manager."
            }
          },
          "required": ["@instanceof", "connection"],
          "description": "Entity manager supposed to work with any entity, automatically find its repository and call its methods, whatever entity type are you passing."
        },
        "QueryRunner": {
          "type": "object",
          "properties": {
            "connection": {
              "$ref": "#/components/schemas/DataSource",
              "description": "Connection used by this query runner."
            },
            "broadcaster": {
              "$ref": "#/components/schemas/Broadcaster",
              "description": "Broadcaster used on this query runner to broadcast entity events."
            },
            "manager": {
              "$ref": "#/components/schemas/EntityManager",
              "description": "Entity manager working only with this query runner."
            },
            "isReleased": {
              "type": "boolean",
              "description": "Indicates if connection for this query runner is released. Once its released, query runner cannot run queries anymore."
            },
            "isTransactionActive": {
              "type": "boolean",
              "description": "Indicates if transaction is in progress."
            },
            "data": {
              "$ref": "#/components/schemas/ObjectLiteral",
              "description": "Stores temporarily user data. Useful for sharing data with subscribers."
            },
            "loadedTables": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Table"
              },
              "description": "All synchronized tables in the database.",
              "deprecated": "Call `getTables()`"
            },
            "loadedViews": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/View"
              },
              "description": "All synchronized views in the database.",
              "deprecated": "Call `getViews()`"
            }
          },
          "required": ["connection", "broadcaster", "manager", "isReleased", "isTransactionActive", "data", "loadedTables", "loadedViews"],
          "description": "Runs queries on a single database connection."
        },
        "Broadcaster": {
          "type": "object",
          "description": "Broadcaster provides a helper methods to broadcast events to the subscribers."
        },
        "ObjectLiteral": {
          "type": "object",
          "description": "Interface of the simple literal object with any string keys."
        },
        "Table": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "database": {
              "type": "string",
              "description": "Database name that this table resides in if it applies."
            },
            "schema": {
              "type": "string",
              "description": "Schema name that this table resides in if it applies."
            },
            "name": {
              "type": "string",
              "description": "May contain database name, schema name and table name, unless they're the current database.\n\nE.g. myDB.mySchema.myTable"
            },
            "columns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TableColumn"
              },
              "description": "Table columns."
            },
            "indices": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TableIndex"
              },
              "description": "Table indices."
            },
            "foreignKeys": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TableForeignKey"
              },
              "description": "Table foreign keys."
            },
            "uniques": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TableUnique"
              },
              "description": "Table unique constraints."
            },
            "checks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TableCheck"
              },
              "description": "Table check constraints."
            },
            "exclusions": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TableExclusion"
              },
              "description": "Table exclusion constraints."
            },
            "justCreated": {
              "type": "boolean",
              "description": "Indicates if table was just created. This is needed, for example to check if we need to skip primary keys creation for new tables."
            },
            "withoutRowid": {
              "type": "boolean",
              "description": "Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement"
            },
            "engine": {
              "type": "string",
              "description": "Table engine."
            },
            "comment": {
              "type": "string",
              "description": "Table comment. Not supported by all database types."
            }
          },
          "required": ["@instanceof", "name", "columns", "indices", "foreignKeys", "uniques", "checks", "exclusions", "justCreated"],
          "description": "Table in the database represented in this class."
        },
        "TableColumn": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "name": {
              "type": "string",
              "description": "Column name."
            },
            "type": {
              "type": "string",
              "description": "Column type."
            },
            "default": {
              "description": "Column's default value."
            },
            "onUpdate": {
              "type": "string",
              "description": "ON UPDATE trigger. Works only for MySQL."
            },
            "isNullable": {
              "type": "boolean",
              "description": "Indicates if column is NULL, or is NOT NULL in the database."
            },
            "isGenerated": {
              "type": "boolean",
              "description": "Indicates if column is auto-generated sequence."
            },
            "generationStrategy": {
              "type": "string",
              "enum": ["uuid", "increment", "rowid", "identity"],
              "description": "Specifies generation strategy if this column will use auto increment. `rowid` option supported only in CockroachDB."
            },
            "isPrimary": {
              "type": "boolean",
              "description": "Indicates if column is a primary key."
            },
            "isUnique": {
              "type": "boolean",
              "description": "Indicates if column has unique value."
            },
            "isArray": {
              "type": "boolean",
              "description": "Indicates if column stores array."
            },
            "comment": {
              "type": "string",
              "description": "Column's comment."
            },
            "length": {
              "type": "string",
              "description": "Column type's length. Used only on some column types. For example type = \"string\" and length = \"100\" means that ORM will create a column with type varchar(100)."
            },
            "width": {
              "type": "number",
              "description": "Column type's display width. Used only on some column types in MySQL. For example, INT(4) specifies an INT with a display width of four digits."
            },
            "charset": {
              "type": "string",
              "description": "Defines column character set."
            },
            "collation": {
              "type": "string",
              "description": "Defines column collation."
            },
            "precision": {
              "type": ["number", "null"],
              "description": "The precision for a decimal (exact numeric) column (applies only for decimal column), which is the maximum number of digits that are stored for the values."
            },
            "scale": {
              "type": "number",
              "description": "The scale for a decimal (exact numeric) column (applies only for decimal column), which represents the number of digits to the right of the decimal point and must not be greater than precision."
            },
            "zerofill": {
              "type": "boolean",
              "description": "Puts ZEROFILL attribute on to numeric column. Works only for MySQL. If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column"
            },
            "unsigned": {
              "type": "boolean",
              "description": "Puts UNSIGNED attribute on to numeric column. Works only for MySQL."
            },
            "enum": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of possible enumerated values."
            },
            "enumName": {
              "type": "string",
              "description": "Exact name of enum"
            },
            "primaryKeyConstraintName": {
              "type": "string",
              "description": "Name of the primary key constraint for primary column."
            },
            "asExpression": {
              "type": "string",
              "description": "Generated column expression."
            },
            "generatedType": {
              "type": "string",
              "enum": ["VIRTUAL", "STORED"],
              "description": "Generated column type."
            },
            "generatedIdentity": {
              "type": "string",
              "enum": ["ALWAYS", "BY DEFAULT"],
              "description": "Identity column type. Supports only in Postgres 10+."
            },
            "spatialFeatureType": {
              "type": "string",
              "description": "Spatial Feature Type (Geometry, Point, Polygon, etc.)"
            },
            "srid": {
              "type": "number",
              "description": "SRID (Spatial Reference ID (EPSG code))"
            }
          },
          "required": [
            "@instanceof",
            "name",
            "type",
            "isNullable",
            "isGenerated",
            "isPrimary",
            "isUnique",
            "isArray",
            "length",
            "zerofill",
            "unsigned"
          ],
          "description": "Table's columns in the database represented in this class."
        },
        "TableIndex": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "name": {
              "type": "string",
              "description": "Index name."
            },
            "columnNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Columns included in this index."
            },
            "isUnique": {
              "type": "boolean",
              "description": "Indicates if this index is unique."
            },
            "isSpatial": {
              "type": "boolean",
              "description": "The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values. Works only in MySQL."
            },
            "isConcurrent": {
              "type": "boolean",
              "description": "Create the index using the CONCURRENTLY modifier Works only in postgres."
            },
            "isFulltext": {
              "type": "boolean",
              "description": "The FULLTEXT modifier indexes the entire column and does not allow prefixing. Works only in MySQL."
            },
            "isNullFiltered": {
              "type": "boolean",
              "description": "NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value. In these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than a normal index that includes NULL values.\n\nWorks only in Spanner."
            },
            "parser": {
              "type": "string",
              "description": "Fulltext parser. Works only in MySQL."
            },
            "where": {
              "type": "string",
              "description": "Index filter condition."
            }
          },
          "required": ["@instanceof", "columnNames", "isUnique", "isSpatial", "isConcurrent", "isFulltext", "isNullFiltered", "where"],
          "description": "Database's table index stored in this class."
        },
        "TableForeignKey": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "name": {
              "type": "string",
              "description": "Name of the foreign key constraint."
            },
            "columnNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Column names which included by this foreign key."
            },
            "referencedDatabase": {
              "type": "string",
              "description": "Database of Table referenced in the foreign key."
            },
            "referencedSchema": {
              "type": "string",
              "description": "Database of Table referenced in the foreign key."
            },
            "referencedTableName": {
              "type": "string",
              "description": "Table referenced in the foreign key."
            },
            "referencedColumnNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Column names which included by this foreign key."
            },
            "onDelete": {
              "type": "string",
              "description": "\"ON DELETE\" of this foreign key, e.g. what action database should perform when referenced stuff is being deleted."
            },
            "onUpdate": {
              "type": "string",
              "description": "\"ON UPDATE\" of this foreign key, e.g. what action database should perform when referenced stuff is being updated."
            },
            "deferrable": {
              "type": "string",
              "description": "Set this foreign key constraint as \"DEFERRABLE\" e.g. check constraints at start or at the end of a transaction"
            }
          },
          "required": ["@instanceof", "columnNames", "referencedTableName", "referencedColumnNames"],
          "description": "Foreign key from the database stored in this class."
        },
        "TableUnique": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "name": {
              "type": "string",
              "description": "Constraint name."
            },
            "columnNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Columns that contains this constraint."
            },
            "deferrable": {
              "type": "string",
              "description": "Set this foreign key constraint as \"DEFERRABLE\" e.g. check constraints at start or at the end of a transaction"
            }
          },
          "required": ["@instanceof", "columnNames"],
          "description": "Database's table unique constraint stored in this class."
        },
        "TableCheck": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "name": {
              "type": "string",
              "description": "Constraint name."
            },
            "columnNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Column that contains this constraint."
            },
            "expression": {
              "type": "string",
              "description": "Check expression."
            }
          },
          "required": ["@instanceof"],
          "description": "Database's table check constraint stored in this class."
        },
        "TableExclusion": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "name": {
              "type": "string",
              "description": "Constraint name."
            },
            "expression": {
              "type": "string",
              "description": "Exclusion expression."
            }
          },
          "required": ["@instanceof"],
          "description": "Database's table exclusion constraint stored in this class."
        },
        "View": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "database": {
              "type": "string",
              "description": "Database name that this view resides in if it applies."
            },
            "schema": {
              "type": "string",
              "description": "Schema name that this view resides in if it applies."
            },
            "name": {
              "type": "string",
              "description": "View name"
            },
            "materialized": {
              "type": "boolean",
              "description": "Indicates if view is materialized."
            },
            "indices": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TableIndex"
              },
              "description": "View Indices"
            },
            "expression": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$comment": "(connection: DataSource) => SelectQueryBuilder<any>",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "connection": {
                          "$ref": "#/components/schemas/DataSource"
                        }
                      },
                      "required": ["connection"],
                      "additionalProperties": false
                    }
                  }
                }
              ],
              "description": "View definition."
            }
          },
          "required": ["@instanceof", "name", "materialized", "indices", "expression"],
          "description": "View in the database represented in this class."
        },
        "MigrationInterface": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Optional migration name, defaults to class name."
            },
            "transaction": {
              "type": "boolean",
              "description": "Optional flag to determine whether to run the migration in a transaction or not. Can only be used when `migrationsTransactionMode` is either \"each\" or \"none\" Defaults to `true` when `migrationsTransactionMode` is \"each\" Defaults to `false` when `migrationsTransactionMode` is \"none\""
            }
          },
          "description": "Migrations should implement this interface and all its methods."
        },
        "EntitySubscriberInterface<any>": {
          "type": "object",
          "description": "Classes that implement this interface are subscribers that subscribe for the specific events in the ORM."
        },
        "EntityMetadata": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "connection": {
              "$ref": "#/components/schemas/DataSource",
              "description": "Connection where this entity metadata is created."
            },
            "tableMetadataArgs": {
              "$ref": "#/components/schemas/TableMetadataArgs",
              "description": "Metadata arguments used to build this entity metadata."
            },
            "closureJunctionTable": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "If entity's table is a closure-typed table, then this entity will have a closure junction table metadata."
            },
            "parentClosureEntityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "If this is entity metadata for a junction closure table then its owner closure table metadata will be set here."
            },
            "parentEntityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Parent's entity metadata. Used in inheritance patterns."
            },
            "childEntityMetadatas": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityMetadata"
              },
              "description": "Children entity metadatas. Used in inheritance patterns."
            },
            "inheritanceTree": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "prototype": {},
                  "length": {
                    "type": "number"
                  },
                  "arguments": {},
                  "caller": {
                    "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                  }
                },
                "required": ["prototype", "length", "arguments", "caller"]
              },
              "description": "All \"inheritance tree\" from a target entity. For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit]. It also contains child entities for single table inheritance."
            },
            "tableType": {
              "$ref": "#/components/schemas/TableType",
              "description": "Table type. Tables can be closure, junction, etc."
            },
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Target class to which this entity metadata is bind. Note, that when using table inheritance patterns target can be different rather then table's target. For virtual tables which lack of real entity (like junction tables) target is equal to their table name."
            },
            "targetName": {
              "type": "string",
              "description": "Gets the name of the target."
            },
            "name": {
              "type": "string",
              "description": "Entity's name. Equal to entity target class's name if target is set to table. If target class is not then then it equals to table name."
            },
            "expression": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$comment": "(connection: DataSource) => SelectQueryBuilder<any>",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "connection": {
                          "$ref": "#/components/schemas/DataSource"
                        }
                      },
                      "required": ["connection"],
                      "additionalProperties": false
                    }
                  }
                }
              ],
              "description": "View's expression. Used in views"
            },
            "dependsOn": {
              "type": "object",
              "properties": {
                "size": {
                  "type": "number"
                }
              },
              "required": ["size"],
              "description": "View's dependencies. Used in views"
            },
            "withoutRowid": {
              "type": "boolean",
              "description": "Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement"
            },
            "givenTableName": {
              "type": "string",
              "description": "Original user-given table name (taken from schema or"
            },
            "tableName": {
              "type": "string",
              "description": "Entity table name in the database. This is final table name of the entity. This name already passed naming strategy, and generated based on multiple criteria, including user table name and global table prefix."
            },
            "tablePath": {
              "type": "string",
              "description": "Entity table path. Contains database name, schema name and table name. E.g. myDB.mySchema.myTable"
            },
            "tableNameWithoutPrefix": {
              "type": "string",
              "description": "Gets the table name without global table prefix. When querying table you need a table name with prefix, but in some scenarios, for example when you want to name a junction table that contains names of two other tables, you may want a table name without prefix."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if schema will be synchronized for this entity or not."
            },
            "engine": {
              "type": "string",
              "description": "Table's database engine type (like \"InnoDB\", \"MyISAM\", etc)."
            },
            "database": {
              "type": "string",
              "description": "Database name."
            },
            "schema": {
              "type": "string",
              "description": "Schema name. Used in Postgres and Sql Server."
            },
            "orderBy": {
              "$ref": "#/components/schemas/OrderByCondition",
              "description": "Specifies a default order by used for queries from this table when no explicit order by is specified."
            },
            "inheritancePattern": {
              "type": "string",
              "const": "STI",
              "description": "If this entity metadata's table using one of the inheritance patterns, then this will contain what pattern it uses."
            },
            "hasNonNullableRelations": {
              "type": "boolean",
              "description": "Checks if there any non-nullable column exist in this entity."
            },
            "isJunction": {
              "type": "boolean",
              "description": "Indicates if this entity metadata of a junction table, or not. Junction table is a table created by many-to-many relationship.\n\nIts also possible to understand if entity is junction via tableType."
            },
            "isAlwaysUsingConstructor": {
              "type": "boolean",
              "description": "Indicates if the entity should be instantiated using the constructor or via allocating a new object via `Object.create()`."
            },
            "treeType": {
              "$ref": "#/components/schemas/TreeType",
              "description": "Indicates if this entity is a tree, what type of tree it is."
            },
            "treeOptions": {
              "$ref": "#/components/schemas/ClosureTreeOptions",
              "description": "Indicates if this entity is a tree, what options of tree it has."
            },
            "isClosureJunction": {
              "type": "boolean",
              "description": "Checks if this table is a junction table of the closure table. This type is for tables that contain junction metadata of the closure tables."
            },
            "hasMultiplePrimaryKeys": {
              "type": "boolean",
              "description": "Checks if entity's table has multiple primary columns."
            },
            "hasUUIDGeneratedColumns": {
              "type": "boolean",
              "description": "Indicates if this entity metadata has uuid generated columns."
            },
            "discriminatorValue": {
              "type": "string",
              "description": "If this entity metadata is a child table of some table, it should have a discriminator value. Used to store a value in a discriminator column."
            },
            "ownColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Entity's column metadatas defined by user."
            },
            "columns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Columns of the entity, including columns that are coming from the embeddeds of this entity."
            },
            "ancestorColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Ancestor columns used only in closure junction tables."
            },
            "descendantColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Descendant columns used only in closure junction tables."
            },
            "nonVirtualColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "All columns except for virtual columns."
            },
            "ownerColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "In the case if this entity metadata is junction table's entity metadata, this will contain all referenced columns of owner entity."
            },
            "inverseColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "In the case if this entity metadata is junction table's entity metadata, this will contain all referenced columns of inverse entity."
            },
            "generatedColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Gets the column with generated flag."
            },
            "objectIdColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "Gets the object id column used with mongodb database."
            },
            "createDateColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "Gets entity column which contains a create date value."
            },
            "updateDateColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "Gets entity column which contains an update date value."
            },
            "deleteDateColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "Gets entity column which contains a delete date value."
            },
            "versionColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "Gets entity column which contains an entity version."
            },
            "discriminatorColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "Gets the discriminator column used to store entity identificator in single-table inheritance tables."
            },
            "treeLevelColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "Special column that stores tree level in tree entities."
            },
            "nestedSetLeftColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "Nested set's left value column. Used only in tree entities with nested set pattern applied."
            },
            "nestedSetRightColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "Nested set's right value column. Used only in tree entities with nested set pattern applied."
            },
            "materializedPathColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "Materialized path column. Used only in tree entities with materialized path pattern applied."
            },
            "primaryColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Gets the primary columns."
            },
            "ownRelations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Entity's relation metadatas."
            },
            "relations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Relations of the entity, including relations that are coming from the embeddeds of this entity."
            },
            "eagerRelations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "List of eager relations this metadata has."
            },
            "lazyRelations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "List of eager relations this metadata has."
            },
            "oneToOneRelations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Gets only one-to-one relations of the entity."
            },
            "ownerOneToOneRelations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Gets only owner one-to-one relations of the entity."
            },
            "oneToManyRelations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Gets only one-to-many relations of the entity."
            },
            "manyToOneRelations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Gets only many-to-one relations of the entity."
            },
            "manyToManyRelations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Gets only many-to-many relations of the entity."
            },
            "ownerManyToManyRelations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Gets only owner many-to-many relations of the entity."
            },
            "relationsWithJoinColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Gets only owner one-to-one and many-to-one relations."
            },
            "treeParentRelation": {
              "$ref": "#/components/schemas/RelationMetadata",
              "description": "Tree parent relation. Used only in tree-tables."
            },
            "treeChildrenRelation": {
              "$ref": "#/components/schemas/RelationMetadata",
              "description": "Tree children relation. Used only in tree-tables."
            },
            "relationIds": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationIdMetadata"
              },
              "description": "Entity's relation id metadatas."
            },
            "relationCounts": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationCountMetadata"
              },
              "description": "Entity's relation id metadatas."
            },
            "foreignKeys": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ForeignKeyMetadata"
              },
              "description": "Entity's foreign key metadatas."
            },
            "embeddeds": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EmbeddedMetadata"
              },
              "description": "Entity's embedded metadatas."
            },
            "allEmbeddeds": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EmbeddedMetadata"
              },
              "description": "All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc."
            },
            "ownIndices": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IndexMetadata"
              },
              "description": "Entity's own indices."
            },
            "indices": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IndexMetadata"
              },
              "description": "Entity's index metadatas."
            },
            "uniques": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/UniqueMetadata"
              },
              "description": "Entity's unique metadatas."
            },
            "ownUniques": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/UniqueMetadata"
              },
              "description": "Entity's own uniques."
            },
            "checks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/CheckMetadata"
              },
              "description": "Entity's check metadatas."
            },
            "exclusions": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ExclusionMetadata"
              },
              "description": "Entity's exclusion metadatas."
            },
            "ownListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Entity's own listener metadatas."
            },
            "listeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Entity listener metadatas."
            },
            "afterLoadListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"AFTER LOAD\" type."
            },
            "beforeInsertListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"BEFORE INSERT\" type."
            },
            "afterInsertListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"AFTER INSERT\" type."
            },
            "beforeUpdateListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"BEFORE UPDATE\" type."
            },
            "afterUpdateListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"AFTER UPDATE\" type."
            },
            "beforeRemoveListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"BEFORE REMOVE\" type."
            },
            "beforeSoftRemoveListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"BEFORE SOFT REMOVE\" type."
            },
            "beforeRecoverListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"BEFORE RECOVER\" type."
            },
            "afterRemoveListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"AFTER REMOVE\" type."
            },
            "afterSoftRemoveListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"AFTER SOFT REMOVE\" type."
            },
            "afterRecoverListeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Listener metadatas with \"AFTER RECOVER\" type."
            },
            "propertiesMap": {
              "$ref": "#/components/schemas/ObjectLiteral",
              "description": "Map of columns and relations of the entity.\n\nexample: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }. This method will create following object: { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }"
            },
            "comment": {
              "type": "string",
              "description": "Table comment. Not supported by all database types."
            }
          },
          "required": [
            "@instanceof",
            "connection",
            "tableMetadataArgs",
            "closureJunctionTable",
            "parentClosureEntityMetadata",
            "parentEntityMetadata",
            "childEntityMetadatas",
            "inheritanceTree",
            "tableType",
            "target",
            "targetName",
            "name",
            "tableName",
            "tablePath",
            "tableNameWithoutPrefix",
            "synchronize",
            "hasNonNullableRelations",
            "isJunction",
            "isAlwaysUsingConstructor",
            "isClosureJunction",
            "hasMultiplePrimaryKeys",
            "hasUUIDGeneratedColumns",
            "ownColumns",
            "columns",
            "ancestorColumns",
            "descendantColumns",
            "nonVirtualColumns",
            "ownerColumns",
            "inverseColumns",
            "generatedColumns",
            "primaryColumns",
            "ownRelations",
            "relations",
            "eagerRelations",
            "lazyRelations",
            "oneToOneRelations",
            "ownerOneToOneRelations",
            "oneToManyRelations",
            "manyToOneRelations",
            "manyToManyRelations",
            "ownerManyToManyRelations",
            "relationsWithJoinColumns",
            "relationIds",
            "relationCounts",
            "foreignKeys",
            "embeddeds",
            "allEmbeddeds",
            "ownIndices",
            "indices",
            "uniques",
            "ownUniques",
            "checks",
            "exclusions",
            "ownListeners",
            "listeners",
            "afterLoadListeners",
            "beforeInsertListeners",
            "afterInsertListeners",
            "beforeUpdateListeners",
            "afterUpdateListeners",
            "beforeRemoveListeners",
            "beforeSoftRemoveListeners",
            "beforeRecoverListeners",
            "afterRemoveListeners",
            "afterSoftRemoveListeners",
            "afterRecoverListeners",
            "propertiesMap"
          ],
          "description": "Contains all entity metadata."
        },
        "TableMetadataArgs": {
          "type": "object",
          "properties": {
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Class to which table is applied. Function target is a table defined in the class. String target is a table defined in a json schema."
            },
            "name": {
              "type": "string",
              "description": "Table's name. If name is not set then table's name will be generated from target's name."
            },
            "type": {
              "$ref": "#/components/schemas/TableType",
              "description": "Table type. Tables can be abstract, closure, junction, embedded, etc."
            },
            "orderBy": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/OrderByCondition"
                },
                {
                  "$comment": "(object: any) => OrderByCondition | any",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "object": {}
                      },
                      "required": ["object"],
                      "additionalProperties": false
                    }
                  }
                }
              ],
              "description": "Specifies a default order by used for queries from this table when no explicit order by is specified."
            },
            "engine": {
              "type": "string",
              "description": "Table's database engine type (like \"InnoDB\", \"MyISAM\", etc)."
            },
            "database": {
              "type": "string",
              "description": "Database name. Used in MySql and Sql Server."
            },
            "schema": {
              "type": "string",
              "description": "Schema name. Used in Postgres and Sql Server."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if schema synchronization is enabled or disabled for this entity. If it will be set to false then schema sync will and migrations ignore this entity. By default schema synchronization is enabled for all entities."
            },
            "expression": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$comment": "(connection: DataSource) => SelectQueryBuilder<any>",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "connection": {
                          "$ref": "#/components/schemas/DataSource"
                        }
                      },
                      "required": ["connection"],
                      "additionalProperties": false
                    }
                  }
                }
              ],
              "description": "View expression."
            },
            "dependsOn": {
              "type": "object",
              "properties": {
                "size": {
                  "type": "number"
                }
              },
              "required": ["size"],
              "description": "View dependencies."
            },
            "materialized": {
              "type": "boolean",
              "description": "Indicates if view is materialized"
            },
            "withoutRowid": {
              "type": "boolean",
              "description": "If set to 'true' this option disables Sqlite's default behaviour of secretly creating an integer primary key column named 'rowid' on table creation."
            },
            "comment": {
              "type": "string",
              "description": "Table comment. Not supported by all database types."
            }
          },
          "required": ["target", "type"],
          "description": "Arguments for TableMetadata class, helps to construct an TableMetadata object."
        },
        "TreeType": {
          "type": "string",
          "enum": ["adjacency-list", "closure-table", "nested-set", "materialized-path"],
          "description": "Tree type. Specifies what table pattern will be used for the tree entity."
        },
        "ClosureTreeOptions": {
          "type": "object",
          "properties": {
            "closureTableName": {
              "type": "string"
            },
            "ancestorColumnName": {
              "$comment": "(column: ColumnMetadata) => string",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "column": {
                      "$ref": "#/components/schemas/ColumnMetadata"
                    }
                  },
                  "required": ["column"],
                  "additionalProperties": false
                }
              }
            },
            "descendantColumnName": {
              "$comment": "(column: ColumnMetadata) => string",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "column": {
                      "$ref": "#/components/schemas/ColumnMetadata"
                    }
                  },
                  "required": ["column"],
                  "additionalProperties": false
                }
              }
            }
          }
        },
        "ColumnMetadata": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Target class where column decorator is used. This may not be always equal to entity metadata (for example embeds or inheritance cases)."
            },
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata where this column metadata is.\n\nFor example for"
            },
            "embeddedMetadata": {
              "$ref": "#/components/schemas/EmbeddedMetadata",
              "description": "Embedded metadata where this column metadata is. If this column is not in embed then this property value is undefined."
            },
            "relationMetadata": {
              "$ref": "#/components/schemas/RelationMetadata",
              "description": "If column is a foreign key of some relation then this relation's metadata will be there. If this column does not have a foreign key then this property value is undefined."
            },
            "propertyName": {
              "type": "string",
              "description": "Class's property name on which this column is applied."
            },
            "type": {
              "$ref": "#/components/schemas/ColumnType",
              "description": "The database type of the column."
            },
            "length": {
              "type": "string",
              "description": "Type's length in the database."
            },
            "width": {
              "type": "number",
              "description": "Type's display width in the database."
            },
            "charset": {
              "type": "string",
              "description": "Defines column character set."
            },
            "collation": {
              "type": "string",
              "description": "Defines column collation."
            },
            "isPrimary": {
              "type": "boolean",
              "description": "Indicates if this column is a primary key."
            },
            "isGenerated": {
              "type": "boolean",
              "description": "Indicates if this column is generated (auto increment or generated other way)."
            },
            "isNullable": {
              "type": "boolean",
              "description": "Indicates if column can contain nulls or not."
            },
            "isSelect": {
              "type": "boolean",
              "description": "Indicates if column is selected by query builder or not."
            },
            "isInsert": {
              "type": "boolean",
              "description": "Indicates if column is inserted by default or not."
            },
            "isUpdate": {
              "type": "boolean",
              "description": "Indicates if column allows updates or not."
            },
            "generationStrategy": {
              "type": "string",
              "enum": ["uuid", "increment", "rowid"],
              "description": "Specifies generation strategy if this column will use auto increment."
            },
            "generatedIdentity": {
              "type": "string",
              "enum": ["ALWAYS", "BY DEFAULT"],
              "description": "Identity column type. Supports only in Postgres 10+."
            },
            "comment": {
              "type": "string",
              "description": "Column comment. This feature is not supported by all databases."
            },
            "default": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                },
                {
                  "type": "array",
                  "items": {
                    "type": ["number", "boolean", "string"]
                  }
                },
                {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                {
                  "$comment": "() => string"
                }
              ],
              "description": "Default database value."
            },
            "onUpdate": {
              "type": "string",
              "description": "ON UPDATE trigger. Works only for MySQL."
            },
            "precision": {
              "type": ["number", "null"],
              "description": "The precision for a decimal (exact numeric) column (applies only for decimal column), which is the maximum number of digits that are stored for the values."
            },
            "scale": {
              "type": "number",
              "description": "The scale for a decimal (exact numeric) column (applies only for decimal column), which represents the number of digits to the right of the decimal point and must not be greater than precision."
            },
            "zerofill": {
              "type": "boolean",
              "description": "Puts ZEROFILL attribute on to numeric column. Works only for MySQL. If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column"
            },
            "unsigned": {
              "type": "boolean",
              "description": "Puts UNSIGNED attribute on to numeric column. Works only for MySQL."
            },
            "enum": {
              "type": "array",
              "items": {
                "type": ["string", "number"]
              },
              "description": "Array of possible enumerated values.\n\n`postgres` and `mysql` store enum values as strings but we want to keep support for numeric and heterogeneous based typescript enums, so we need (string|number)[]"
            },
            "enumName": {
              "type": "string",
              "description": "Exact name of enum"
            },
            "asExpression": {
              "type": "string",
              "description": "Generated column expression."
            },
            "generatedType": {
              "type": "string",
              "enum": ["VIRTUAL", "STORED"],
              "description": "Generated column type."
            },
            "hstoreType": {
              "type": "string",
              "enum": ["object", "string"],
              "description": "Return type of HSTORE column. Returns value as string or as object."
            },
            "isArray": {
              "type": "boolean",
              "description": "Indicates if this column is an array."
            },
            "propertyPath": {
              "type": "string",
              "description": "Gets full path to this column property (including column property name). Full path is relevant when column is used in embeds (one or multiple nested). For example it will return \"counters.subcounters.likes\". If property is not in embeds then it returns just property name of the column."
            },
            "propertyAliasName": {
              "type": "string",
              "description": "Same as property path, but dots are replaced with '_'. Used in query builder statements."
            },
            "databasePath": {
              "type": "string",
              "description": "Gets full path to this column database name (including column database name). Full path is relevant when column is used in embeds (one or multiple nested). For example it will return \"counters.subcounters.likes\". If property is not in embeds then it returns just database name of the column."
            },
            "databaseName": {
              "type": "string",
              "description": "Complete column name in the database including its embedded prefixes."
            },
            "databaseNameWithoutPrefixes": {
              "type": "string",
              "description": "Database name in the database without embedded prefixes applied."
            },
            "givenDatabaseName": {
              "type": "string",
              "description": "Database name set by entity metadata builder, not yet passed naming strategy process and without embedded prefixes."
            },
            "isVirtual": {
              "type": "boolean",
              "description": "Indicates if column is virtual. Virtual columns are not mapped to the entity."
            },
            "isVirtualProperty": {
              "type": "boolean",
              "description": "Indicates if column is a virtual property. Virtual properties are not mapped to the entity. This property is used in tandem the virtual column decorator."
            },
            "query": {
              "$comment": "(alias: string) => string",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "alias": {
                      "type": "string"
                    }
                  },
                  "required": ["alias"],
                  "additionalProperties": false
                }
              },
              "description": "Query to be used to populate the column data. This query is used when generating the relational db script. The query function is called with the current entities alias either defined by the Entity Decorator or automatically"
            },
            "isDiscriminator": {
              "type": "boolean",
              "description": "Indicates if column is discriminator. Discriminator columns are not mapped to the entity."
            },
            "isTreeLevel": {
              "type": "boolean",
              "description": "Indicates if column is tree-level column. Tree-level columns are used in closure entities."
            },
            "isCreateDate": {
              "type": "boolean",
              "description": "Indicates if this column contains an entity creation date."
            },
            "isUpdateDate": {
              "type": "boolean",
              "description": "Indicates if this column contains an entity update date."
            },
            "isDeleteDate": {
              "type": "boolean",
              "description": "Indicates if this column contains an entity delete date."
            },
            "isVersion": {
              "type": "boolean",
              "description": "Indicates if this column contains an entity version."
            },
            "isObjectId": {
              "type": "boolean",
              "description": "Indicates if this column contains an object id."
            },
            "referencedColumn": {
              "$ref": "#/components/schemas/ColumnMetadata",
              "description": "If this column is foreign key then it references some other column, and this property will contain reference to this column."
            },
            "primaryKeyConstraintName": {
              "type": "string",
              "description": "If this column is primary key then this specifies the name for it."
            },
            "foreignKeyConstraintName": {
              "type": "string",
              "description": "If this column is foreign key then this specifies the name for it."
            },
            "transformer": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ValueTransformer"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ValueTransformer"
                  }
                }
              ],
              "description": "Specifies a value transformer that is to be used to (un)marshal this column when reading or writing to the database."
            },
            "closureType": {
              "type": "string",
              "enum": ["ancestor", "descendant"],
              "description": "Column type in the case if this column is in the closure table. Column can be ancestor or descendant in the closure tables."
            },
            "isNestedSetLeft": {
              "type": "boolean",
              "description": "Indicates if this column is nested set's left column. Used only in tree entities with nested-set type."
            },
            "isNestedSetRight": {
              "type": "boolean",
              "description": "Indicates if this column is nested set's right column. Used only in tree entities with nested-set type."
            },
            "isMaterializedPath": {
              "type": "boolean",
              "description": "Indicates if this column is materialized path's path column. Used only in tree entities with materialized path type."
            },
            "spatialFeatureType": {
              "type": "string",
              "description": "Spatial Feature Type (Geometry, Point, Polygon, etc.)"
            },
            "srid": {
              "type": "number",
              "description": "SRID (Spatial Reference ID (EPSG code))"
            }
          },
          "required": [
            "@instanceof",
            "target",
            "entityMetadata",
            "propertyName",
            "type",
            "length",
            "isPrimary",
            "isGenerated",
            "isNullable",
            "isSelect",
            "isInsert",
            "isUpdate",
            "zerofill",
            "unsigned",
            "isArray",
            "propertyPath",
            "propertyAliasName",
            "databasePath",
            "databaseName",
            "databaseNameWithoutPrefixes",
            "isVirtual",
            "isVirtualProperty",
            "isDiscriminator",
            "isTreeLevel",
            "isCreateDate",
            "isUpdateDate",
            "isDeleteDate",
            "isVersion",
            "isObjectId",
            "isNestedSetLeft",
            "isNestedSetRight",
            "isMaterializedPath"
          ],
          "description": "This metadata contains all information about entity's column."
        },
        "EmbeddedMetadata": {
          "type": "object",
          "properties": {
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata where this embedded is."
            },
            "parentEmbeddedMetadata": {
              "$ref": "#/components/schemas/EmbeddedMetadata",
              "description": "Parent embedded in the case if this embedded inside other embedded."
            },
            "type": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Embedded target type."
            },
            "propertyName": {
              "type": "string",
              "description": "Property name on which this embedded is attached."
            },
            "propertyPath": {
              "type": "string",
              "description": "Gets full path to this embedded property (including embedded property name). Full path is relevant when embedded is used inside other embeds (one or multiple nested). For example it will return \"counters.subcounters\"."
            },
            "columns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Columns inside this embed."
            },
            "relations": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Relations inside this embed."
            },
            "listeners": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Entity listeners inside this embed."
            },
            "indices": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IndexMetadata"
              },
              "description": "Indices applied to the embed columns."
            },
            "uniques": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/UniqueMetadata"
              },
              "description": "Uniques applied to the embed columns."
            },
            "relationIds": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationIdMetadata"
              },
              "description": "Relation ids inside this embed."
            },
            "relationCounts": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationCountMetadata"
              },
              "description": "Relation counts inside this embed."
            },
            "embeddeds": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EmbeddedMetadata"
              },
              "description": "Nested embeddable in this embeddable (which has current embedded as parent embedded)."
            },
            "isAlwaysUsingConstructor": {
              "type": "boolean",
              "description": "Indicates if the entity should be instantiated using the constructor or via allocating a new object via `Object.create()`."
            },
            "isArray": {
              "type": "boolean",
              "description": "Indicates if this embedded is in array mode.\n\nThis option works only in mongodb."
            },
            "customPrefix": {
              "type": ["string", "boolean"],
              "description": "Prefix of the embedded, used instead of propertyName. If set to empty string or false, then prefix is not set at all."
            },
            "prefix": {
              "type": "string",
              "description": "Gets the prefix of the columns. By default its a property name of the class where this prefix is. But if custom prefix is set then it takes its value as a prefix. However if custom prefix is set to empty string or false, then prefix to column is not applied at all."
            },
            "parentPropertyNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Returns array of property names of current embed and all its parent embeds.\n\nexample: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds we need to get value of \"id\" column from the post real entity object. this method will return [\"data\", \"information\", \"counters\"]"
            },
            "parentPrefixes": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Returns array of prefixes of current embed and all its parent embeds."
            },
            "embeddedMetadataTree": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EmbeddedMetadata"
              },
              "description": "Returns embed metadatas from all levels of the parent tree.\n\nexample: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]"
            },
            "columnsFromTree": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Embed metadatas from all levels of the parent tree.\n\nexample: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]"
            },
            "relationsFromTree": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationMetadata"
              },
              "description": "Relations of this embed and all relations from its child embeds."
            },
            "listenersFromTree": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EntityListenerMetadata"
              },
              "description": "Relations of this embed and all relations from its child embeds."
            },
            "indicesFromTree": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IndexMetadata"
              },
              "description": "Indices of this embed and all indices from its child embeds."
            },
            "uniquesFromTree": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/UniqueMetadata"
              },
              "description": "Uniques of this embed and all uniques from its child embeds."
            },
            "relationIdsFromTree": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationIdMetadata"
              },
              "description": "Relation ids of this embed and all relation ids from its child embeds."
            },
            "relationCountsFromTree": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationCountMetadata"
              },
              "description": "Relation counts of this embed and all relation counts from its child embeds."
            }
          },
          "required": [
            "entityMetadata",
            "type",
            "propertyName",
            "propertyPath",
            "columns",
            "relations",
            "listeners",
            "indices",
            "uniques",
            "relationIds",
            "relationCounts",
            "embeddeds",
            "isAlwaysUsingConstructor",
            "isArray",
            "prefix",
            "parentPropertyNames",
            "parentPrefixes",
            "embeddedMetadataTree",
            "columnsFromTree",
            "relationsFromTree",
            "listenersFromTree",
            "indicesFromTree",
            "uniquesFromTree",
            "relationIdsFromTree",
            "relationCountsFromTree"
          ],
          "description": "Contains all information about entity's embedded property."
        },
        "RelationMetadata": {
          "type": "object",
          "properties": {
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata of the entity where this relation is placed.\n\nFor example for"
            },
            "inverseEntityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata of the entity that is targeted by this relation.\n\nFor example for"
            },
            "junctionEntityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata of the junction table. Junction tables have their own entity metadata objects. Defined only for many-to-many relations."
            },
            "embeddedMetadata": {
              "$ref": "#/components/schemas/EmbeddedMetadata",
              "description": "Embedded metadata where this relation is. If this relation is not in embed then this property value is undefined."
            },
            "relationType": {
              "$ref": "#/components/schemas/RelationType",
              "description": "Relation type, e.g. is it one-to-one, one-to-many, many-to-one or many-to-many."
            },
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Target entity to which this relation is applied. Target IS NOT equal to entityMetadata.target, because relation\n\nFor example for"
            },
            "propertyName": {
              "type": "string",
              "description": "Target's property name to which relation decorator is applied."
            },
            "propertyPath": {
              "type": "string",
              "description": "Gets full path to this column property (including relation name). Full path is relevant when column is used in embeds (one or multiple nested). For example it will return \"counters.subcounters.likes\". If property is not in embeds then it returns just property name of the column."
            },
            "isTreeParent": {
              "type": "boolean",
              "description": "Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables."
            },
            "isTreeChildren": {
              "type": "boolean",
              "description": "Indicates if this is a children (can be only one-to-many relation) relation in the tree tables."
            },
            "isPrimary": {
              "type": "boolean",
              "description": "Indicates if this relation's column is a primary key. Can be used only for many-to-one and owner one-to-one relations."
            },
            "isLazy": {
              "type": "boolean",
              "description": "Indicates if this relation is lazily loaded."
            },
            "isEager": {
              "type": "boolean",
              "description": "Indicates if this relation is eagerly loaded."
            },
            "persistenceEnabled": {
              "type": "boolean",
              "description": "Indicates if persistence is enabled for the relation. By default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it. If its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality. This is useful for performance optimization since its disabling avoid multiple extra queries during entity save."
            },
            "orphanedRowAction": {
              "type": "string",
              "enum": ["nullify", "delete", "soft-delete", "disable"],
              "description": "When a parent is saved (with cascading but) without a child row that still exists in database, this will control what shall happen to them. delete will remove these rows from database. nullify will remove the relation key. skip will keep the relation intact. Removal of related item is only possible through its own repo."
            },
            "isCascadeInsert": {
              "type": "boolean",
              "description": "If set to true then related objects are allowed to be inserted to the database."
            },
            "isCascadeUpdate": {
              "type": "boolean",
              "description": "If set to true then related objects are allowed to be updated in the database."
            },
            "isCascadeRemove": {
              "type": "boolean",
              "description": "If set to true then related objects are allowed to be remove from the database."
            },
            "isCascadeSoftRemove": {
              "type": "boolean",
              "description": "If set to true then related objects are allowed to be soft-removed from the database."
            },
            "isCascadeRecover": {
              "type": "boolean",
              "description": "If set to true then related objects are allowed to be recovered from the database."
            },
            "isNullable": {
              "type": "boolean",
              "description": "Indicates if relation column value can be nullable or not."
            },
            "onDelete": {
              "$ref": "#/components/schemas/OnDeleteType",
              "description": "What to do with a relation on deletion of the row containing a foreign key."
            },
            "onUpdate": {
              "$ref": "#/components/schemas/OnUpdateType",
              "description": "What to do with a relation on update of the row containing a foreign key."
            },
            "deferrable": {
              "$ref": "#/components/schemas/DeferrableType",
              "description": "What to do with a relation on update of the row containing a foreign key."
            },
            "createForeignKeyConstraints": {
              "type": "boolean",
              "description": "Indicates whether foreign key constraints will be created for join columns. Can be used only for many-to-one and owner one-to-one relations. Defaults to true."
            },
            "type": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Gets the property's type to which this relation is applied.\n\nFor example for"
            },
            "isOwning": {
              "type": "boolean",
              "description": "Indicates if this side is an owner of this relation."
            },
            "isOneToOne": {
              "type": "boolean",
              "description": "Checks if this relation's type is \"one-to-one\"."
            },
            "isOneToOneOwner": {
              "type": "boolean",
              "description": "Checks if this relation is owner side of the \"one-to-one\" relation. Owner side means this side of relation has a join column in the table."
            },
            "isWithJoinColumn": {
              "type": "boolean",
              "description": "Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side)."
            },
            "isOneToOneNotOwner": {
              "type": "boolean",
              "description": "Checks if this relation is NOT owner side of the \"one-to-one\" relation. NOT owner side means this side of relation does not have a join column in the table."
            },
            "isOneToMany": {
              "type": "boolean",
              "description": "Checks if this relation's type is \"one-to-many\"."
            },
            "isManyToOne": {
              "type": "boolean",
              "description": "Checks if this relation's type is \"many-to-one\"."
            },
            "isManyToMany": {
              "type": "boolean",
              "description": "Checks if this relation's type is \"many-to-many\"."
            },
            "isManyToManyOwner": {
              "type": "boolean",
              "description": "Checks if this relation's type is \"many-to-many\", and is owner side of the relationship. Owner side means this side of relation has a join table."
            },
            "isManyToManyNotOwner": {
              "type": "boolean",
              "description": "Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship. Not owner side means this side of relation does not have a join table."
            },
            "inverseSidePropertyPath": {
              "type": "string",
              "description": "Gets the property path of the inverse side of the relation."
            },
            "givenInverseSidePropertyFactory": {
              "$ref": "#/components/schemas/PropertyTypeFactory<any>",
              "description": "Inverse side of the relation set by user.\n\nInverse side set in the relation can be either string - property name of the column on inverse side, either can be a function that accepts a map of properties with the object and returns one of them. Second approach is used to achieve type-safety."
            },
            "inverseRelation": {
              "$ref": "#/components/schemas/RelationMetadata",
              "description": "Gets the relation metadata of the inverse side of this relation."
            },
            "joinTableName": {
              "type": "string",
              "description": "Join table name."
            },
            "foreignKeys": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ForeignKeyMetadata"
              },
              "description": "Foreign keys created for this relation."
            },
            "joinColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Join table columns. Join columns can be obtained only from owner side of the relation. From non-owner side of the relation join columns will be empty. If this relation is a many-to-one/one-to-one then it takes join columns from the current entity. If this relation is many-to-many then it takes all owner join columns from the junction entity."
            },
            "inverseJoinColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Inverse join table columns. Inverse join columns are supported only for many-to-many relations and can be obtained only from owner side of the relation. From non-owner side of the relation join columns will be undefined."
            }
          },
          "required": [
            "entityMetadata",
            "inverseEntityMetadata",
            "relationType",
            "target",
            "propertyName",
            "propertyPath",
            "isTreeParent",
            "isTreeChildren",
            "isPrimary",
            "isLazy",
            "isEager",
            "persistenceEnabled",
            "isCascadeInsert",
            "isCascadeUpdate",
            "isCascadeRemove",
            "isCascadeSoftRemove",
            "isCascadeRecover",
            "isNullable",
            "createForeignKeyConstraints",
            "type",
            "isOwning",
            "isOneToOne",
            "isOneToOneOwner",
            "isWithJoinColumn",
            "isOneToOneNotOwner",
            "isOneToMany",
            "isManyToOne",
            "isManyToMany",
            "isManyToManyOwner",
            "isManyToManyNotOwner",
            "inverseSidePropertyPath",
            "givenInverseSidePropertyFactory",
            "joinTableName",
            "foreignKeys",
            "joinColumns",
            "inverseJoinColumns"
          ],
          "description": "Contains all information about some entity's relation."
        },
        "RelationType": {
          "type": "string",
          "enum": ["one-to-one", "one-to-many", "many-to-one", "many-to-many"],
          "description": "All types that relation can be."
        },
        "PropertyTypeFactory<any>": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$comment": "(t: T) => string | any",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "t": {}
                  },
                  "required": ["t"],
                  "additionalProperties": false
                }
              }
            }
          ],
          "description": "Contains the name of the property of the object, or the function that returns this name."
        },
        "ForeignKeyMetadata": {
          "type": "object",
          "properties": {
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata where this foreign key is."
            },
            "referencedEntityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata which this foreign key references."
            },
            "columns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Array of columns of this foreign key."
            },
            "referencedColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Array of referenced columns."
            },
            "onDelete": {
              "$ref": "#/components/schemas/OnDeleteType",
              "description": "What to do with a relation on deletion of the row containing a foreign key."
            },
            "onUpdate": {
              "$ref": "#/components/schemas/OnUpdateType",
              "description": "What to do with a relation on update of the row containing a foreign key."
            },
            "deferrable": {
              "$ref": "#/components/schemas/DeferrableType",
              "description": "When to check the constraints of a foreign key."
            },
            "referencedTablePath": {
              "type": "string",
              "description": "Gets the table name to which this foreign key is referenced."
            },
            "name": {
              "type": "string",
              "description": "Gets foreign key name. If unique constraint name was given by a user then it stores givenName. If unique constraint name was not given then its generated."
            },
            "columnNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Gets array of column names."
            },
            "referencedColumnNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Gets array of referenced column names."
            },
            "givenName": {
              "type": "string",
              "description": "User specified unique constraint name."
            }
          },
          "required": [
            "entityMetadata",
            "referencedEntityMetadata",
            "columns",
            "referencedColumns",
            "referencedTablePath",
            "name",
            "columnNames",
            "referencedColumnNames"
          ],
          "description": "Contains all information about entity's foreign key."
        },
        "EntityListenerMetadata": {
          "type": "object",
          "properties": {
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata of the listener."
            },
            "embeddedMetadata": {
              "$ref": "#/components/schemas/EmbeddedMetadata",
              "description": "Embedded metadata of the listener, in the case if listener is in embedded."
            },
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Target class to which metadata is applied. This can be different then entityMetadata.target in the case if listener is in the embedded."
            },
            "propertyName": {
              "type": "string",
              "description": "Target's property name to which this metadata is applied."
            },
            "type": {
              "$ref": "#/components/schemas/EventListenerType",
              "description": "The type of the listener."
            }
          },
          "required": ["entityMetadata", "target", "propertyName", "type"],
          "description": "This metadata contains all information about entity's listeners."
        },
        "EventListenerType": {
          "type": "string",
          "enum": [
            "after-load",
            "before-insert",
            "after-insert",
            "before-update",
            "after-update",
            "before-remove",
            "after-remove",
            "before-soft-remove",
            "after-soft-remove",
            "before-recover",
            "after-recover"
          ],
          "description": "All types that entity listener can be."
        },
        "IndexMetadata": {
          "type": "object",
          "properties": {
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata of the class to which this index is applied."
            },
            "embeddedMetadata": {
              "$ref": "#/components/schemas/EmbeddedMetadata",
              "description": "Embedded metadata if this index was applied on embedded."
            },
            "isUnique": {
              "type": "boolean",
              "description": "Indicates if this index must be unique."
            },
            "isSpatial": {
              "type": "boolean",
              "description": "The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values. Works only in MySQL."
            },
            "isFulltext": {
              "type": "boolean",
              "description": "The FULLTEXT modifier indexes the entire column and does not allow prefixing. Works only in MySQL."
            },
            "isNullFiltered": {
              "type": "boolean",
              "description": "NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value. In these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than a normal index that includes NULL values.\n\nWorks only in Spanner."
            },
            "parser": {
              "type": "string",
              "description": "Fulltext parser. Works only in MySQL."
            },
            "synchronize": {
              "type": "boolean",
              "description": "Indicates if this index must synchronize with database index."
            },
            "isSparse": {
              "type": "boolean",
              "description": "If true, the index only references documents with the specified field. These indexes use less space but behave differently in some situations (particularly sorts). This option is only supported for mongodb database."
            },
            "isBackground": {
              "type": "boolean",
              "description": "Builds the index in the background so that building an index an does not block other database activities. This option is only supported for mongodb database."
            },
            "isConcurrent": {
              "type": "boolean",
              "description": "Builds the index using the concurrently option. This options is only supported for postgres database."
            },
            "expireAfterSeconds": {
              "type": "number",
              "description": "Specifies a time to live, in seconds. This option is only supported for mongodb database."
            },
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Target class to which metadata is applied."
            },
            "columns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Indexed columns."
            },
            "givenName": {
              "type": "string",
              "description": "User specified index name."
            },
            "givenColumnNames": {
              "anyOf": [
                {
                  "$comment": "(object?: any) => any[] | {\n        [key: string]: number;\n    }",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "object": {}
                      },
                      "additionalProperties": false
                    }
                  }
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "User specified column names."
            },
            "name": {
              "type": "string",
              "description": "Final index name. If index name was given by a user then it stores normalized (by naming strategy) givenName. If index name was not given then its generated."
            },
            "where": {
              "type": "string",
              "description": "Index filter condition."
            },
            "columnNamesWithOrderingMap": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              },
              "description": "Map of column names with order set. Used only by MongoDB driver."
            }
          },
          "required": [
            "entityMetadata",
            "isUnique",
            "isSpatial",
            "isFulltext",
            "isNullFiltered",
            "synchronize",
            "columns",
            "name",
            "columnNamesWithOrderingMap"
          ],
          "description": "Index metadata contains all information about table's index."
        },
        "UniqueMetadata": {
          "type": "object",
          "properties": {
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata of the class to which this unique constraint is applied."
            },
            "embeddedMetadata": {
              "$ref": "#/components/schemas/EmbeddedMetadata",
              "description": "Embedded metadata if this unique was applied on embedded."
            },
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Target class to which metadata is applied."
            },
            "columns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Unique columns."
            },
            "deferrable": {
              "$ref": "#/components/schemas/DeferrableType",
              "description": "Indicate if unique constraints can be deferred."
            },
            "givenName": {
              "type": "string",
              "description": "User specified unique constraint name."
            },
            "givenColumnNames": {
              "anyOf": [
                {
                  "$comment": "(object?: any) => any[] | {\n        [key: string]: number;\n    }",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "object": {}
                      },
                      "additionalProperties": false
                    }
                  }
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "User specified column names."
            },
            "name": {
              "type": "string",
              "description": "Final unique constraint name. If unique constraint name was given by a user then it stores normalized (by naming strategy) givenName. If unique constraint name was not given then its generated."
            },
            "columnNamesWithOrderingMap": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              },
              "description": "Map of column names with order set. Used only by MongoDB driver."
            }
          },
          "required": ["entityMetadata", "columns", "name", "columnNamesWithOrderingMap"],
          "description": "Unique metadata contains all information about table's unique constraints."
        },
        "RelationIdMetadata": {
          "type": "object",
          "properties": {
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata where this column metadata is."
            },
            "relation": {
              "$ref": "#/components/schemas/RelationMetadata",
              "description": "Relation from which ids will be extracted."
            },
            "relationNameOrFactory": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$comment": "(object: any) => any",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "object": {}
                      },
                      "required": ["object"],
                      "additionalProperties": false
                    }
                  }
                }
              ],
              "description": "Relation name which need to count."
            },
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Target class to which metadata is applied."
            },
            "propertyName": {
              "type": "string",
              "description": "Target's property name to which this metadata is applied."
            },
            "alias": {
              "type": "string",
              "description": "Alias of the joined (destination) table."
            },
            "queryBuilderFactory": {
              "$comment": "(qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "qb": {
                      "$ref": "#/components/schemas/SelectQueryBuilder<any>"
                    }
                  },
                  "required": ["qb"],
                  "additionalProperties": false
                }
              },
              "description": "Extra condition applied to \"ON\" section of join."
            }
          },
          "required": ["entityMetadata", "relation", "relationNameOrFactory", "target", "propertyName"],
          "description": "Contains all information about entity's relation count."
        },
        "SelectQueryBuilder<any>": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "connection": {
              "$ref": "#/components/schemas/DataSource",
              "description": "Connection on which QueryBuilder was created."
            },
            "expressionMap": {
              "$ref": "#/components/schemas/QueryExpressionMap",
              "description": "Contains all properties of the QueryBuilder that needs to be build a final query."
            }
          },
          "required": ["@instanceof", "connection", "expressionMap"],
          "description": "Allows to build complex sql queries in a fashion way and execute those queries."
        },
        "QueryExpressionMap": {
          "type": "object",
          "properties": {
            "relationLoadStrategy": {
              "type": "string",
              "enum": ["join", "query"],
              "description": "Strategy to load relations."
            },
            "queryEntity": {
              "type": "boolean",
              "description": "Indicates if QueryBuilder used to select entities and not a raw results."
            },
            "mainAlias": {
              "$ref": "#/components/schemas/Alias",
              "description": "Main alias is a main selection object selected by QueryBuilder."
            },
            "aliases": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Alias"
              },
              "description": "All aliases (including main alias) used in the query."
            },
            "queryType": {
              "type": "string",
              "enum": ["select", "update", "delete", "insert", "relation", "soft-delete", "restore"],
              "description": "Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries."
            },
            "selects": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SelectQuery"
              },
              "description": "Data needs to be SELECT-ed."
            },
            "maxExecutionTime": {
              "type": "number",
              "description": "Max execution time in millisecond."
            },
            "selectDistinct": {
              "type": "boolean",
              "description": "Whether SELECT is DISTINCT."
            },
            "selectDistinctOn": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "SELECT DISTINCT ON query (postgres)."
            },
            "valuesSet": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ObjectLiteral"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ObjectLiteral"
                  }
                }
              ],
              "description": "If update query was used, it needs \"update set\" - properties which will be updated by this query. If insert query was used, it needs \"insert set\" - values that needs to be inserted."
            },
            "returning": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Optional returning (or output) clause for insert, update or delete queries."
            },
            "extraReturningColumns": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ColumnMetadata"
              },
              "description": "Extra returning columns to be added to the returning statement if driver supports it."
            },
            "onConflict": {
              "type": "string",
              "description": "Optional on conflict statement used in insertion query in postgres."
            },
            "onIgnore": {
              "type": "boolean",
              "description": "Optional on ignore statement used in insertion query in databases."
            },
            "onUpdate": {
              "type": "object",
              "properties": {
                "conflict": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  ]
                },
                "columns": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "overwrite": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "skipUpdateIfNoValuesChanged": {
                  "type": "boolean"
                },
                "indexPredicate": {
                  "type": "string"
                },
                "upsertType": {
                  "$ref": "#/components/schemas/UpsertType"
                }
              },
              "description": "Optional on update statement used in insertion query in databases."
            },
            "joinAttributes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JoinAttribute"
              },
              "description": "JOIN queries."
            },
            "relationIdAttributes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationIdAttribute"
              },
              "description": "RelationId queries."
            },
            "relationCountAttributes": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RelationCountAttribute"
              },
              "description": "Relation count queries."
            },
            "wheres": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/WhereClause"
              },
              "description": "WHERE queries."
            },
            "havings": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": ["simple", "and", "or"]
                  },
                  "condition": {
                    "type": "string"
                  }
                },
                "required": ["type", "condition"]
              },
              "description": "HAVING queries."
            },
            "orderBys": {
              "$ref": "#/components/schemas/OrderByCondition",
              "description": "ORDER BY queries."
            },
            "groupBys": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "GROUP BY queries."
            },
            "limit": {
              "type": "number",
              "description": "LIMIT query."
            },
            "offset": {
              "type": "number",
              "description": "OFFSET query."
            },
            "skip": {
              "type": "number",
              "description": "Number of rows to skip of result using pagination."
            },
            "take": {
              "type": "number",
              "description": "Number of rows to take using pagination."
            },
            "useIndex": {
              "type": "string",
              "description": "Use certain index for the query.\n\nSELECT * FROM table_name USE INDEX (col1_index, col2_index) WHERE col1=1 AND col2=2 AND col3=3;"
            },
            "lockMode": {
              "type": "string",
              "enum": [
                "optimistic",
                "pessimistic_read",
                "pessimistic_write",
                "dirty_read",
                "pessimistic_partial_write",
                "pessimistic_write_or_fail",
                "for_no_key_update",
                "for_key_share"
              ],
              "description": "Locking mode."
            },
            "lockVersion": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "string",
                  "format": "date-time"
                }
              ],
              "description": "Current version of the entity, used for locking."
            },
            "lockTables": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tables to be specified in the \"FOR UPDATE OF\" clause, referred by their alias"
            },
            "onLocked": {
              "type": "string",
              "enum": ["nowait", "skip_locked"],
              "description": "Modify behavior when encountering locked rows. NOWAIT or SKIP LOCKED"
            },
            "withDeleted": {
              "type": "boolean",
              "description": "Indicates if soft-deleted rows should be included in entity result. By default the soft-deleted rows are not included."
            },
            "parameters": {
              "$ref": "#/components/schemas/ObjectLiteral",
              "description": "Parameters used to be escaped in final query."
            },
            "disableEscaping": {
              "type": "boolean",
              "description": "Indicates if alias, table names and column names will be escaped by driver, or not.\n\ntodo: rename to isQuotingDisabled, also think if it should be named \"escaping\""
            },
            "enableRelationIdValues": {
              "type": "boolean",
              "description": "Indicates if virtual columns should be included in entity result.\n\ntodo: what to do with it? is it properly used? what about persistence?"
            },
            "extraAppendedAndWhereCondition": {
              "type": "string",
              "description": "Extra where condition appended to the end of original where conditions with AND keyword. Original condition will be wrapped into brackets."
            },
            "subQuery": {
              "type": "boolean",
              "description": "Indicates if query builder creates a subquery."
            },
            "aliasNamePrefixingEnabled": {
              "type": "boolean",
              "description": "Indicates if property names are prefixed with alias names during property replacement. By default this is enabled, however we need this because aliases are not supported in UPDATE and DELETE queries, but user can use them in WHERE expressions."
            },
            "cache": {
              "type": "boolean",
              "description": "Indicates if query result cache is enabled or not. It is undefined by default to avoid overriding the `alwaysEnabled` config"
            },
            "cacheDuration": {
              "type": "number",
              "description": "Time in milliseconds in which cache will expire. If not set then global caching time will be used."
            },
            "cacheId": {
              "type": "string",
              "description": "Cache id. Used to identifier your cache queries."
            },
            "options": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SelectQueryBuilderOption"
              },
              "description": "Options that define QueryBuilder behaviour."
            },
            "relationPropertyPath": {
              "type": "string",
              "description": "Property path of relation to work with. Used in relational query builder."
            },
            "of": {
              "anyOf": [
                {},
                {
                  "type": "array",
                  "items": {}
                }
              ],
              "description": "Entity (target) which relations will be updated."
            },
            "insertColumns": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of columns where data should be inserted. Used in INSERT query."
            },
            "whereEntities": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ObjectLiteral"
              },
              "description": "Used if user wants to update or delete a specific entities."
            },
            "updateEntity": {
              "type": "boolean",
              "description": "Indicates if entity must be updated after insertion / updation. This may produce extra query or use RETURNING / OUTPUT statement (depend on database)."
            },
            "callListeners": {
              "type": "boolean",
              "description": "Indicates if listeners and subscribers must be called before and after query execution."
            },
            "useTransaction": {
              "type": "boolean",
              "description": "Indicates if query must be wrapped into transaction."
            },
            "timeTravel": {
              "type": ["boolean", "string"],
              "description": "Indicates if query should be time travel query https://www.cockroachlabs.com/docs/stable/as-of-system-time.html"
            },
            "nativeParameters": {
              "$ref": "#/components/schemas/ObjectLiteral",
              "description": "Extra parameters.",
              "deprecated": "Use standard parameters instead"
            },
            "comment": {
              "type": "string",
              "description": "Query Comment to include extra information for debugging or other purposes."
            },
            "locallyGenerated": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/ObjectLiteral"
              },
              "description": "Items from an entity that have been locally generated & are recorded here for later use. Examples include the UUID generation when the database does not natively support it. These are included in the entity index order."
            },
            "commonTableExpressions": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "queryBuilder": {
                    "anyOf": [
                      {
                        "$ref": "#/components/schemas/QueryBuilder<any>"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "alias": {
                    "type": "string"
                  },
                  "options": {
                    "$ref": "#/components/schemas/QueryBuilderCteOptions"
                  }
                },
                "required": ["queryBuilder", "alias", "options"]
              }
            }
          },
          "required": [
            "relationLoadStrategy",
            "queryEntity",
            "aliases",
            "queryType",
            "selects",
            "maxExecutionTime",
            "selectDistinct",
            "selectDistinctOn",
            "returning",
            "extraReturningColumns",
            "onConflict",
            "onIgnore",
            "onUpdate",
            "joinAttributes",
            "relationIdAttributes",
            "relationCountAttributes",
            "wheres",
            "havings",
            "orderBys",
            "groupBys",
            "withDeleted",
            "parameters",
            "disableEscaping",
            "enableRelationIdValues",
            "extraAppendedAndWhereCondition",
            "subQuery",
            "aliasNamePrefixingEnabled",
            "cacheDuration",
            "cacheId",
            "options",
            "relationPropertyPath",
            "of",
            "insertColumns",
            "whereEntities",
            "updateEntity",
            "callListeners",
            "useTransaction",
            "nativeParameters",
            "locallyGenerated",
            "commonTableExpressions"
          ],
          "description": "Contains all properties of the QueryBuilder that needs to be build a final query."
        },
        "Alias": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": ["from", "select", "join", "other"]
            },
            "name": {
              "type": "string"
            },
            "tablePath": {
              "type": "string",
              "description": "Table on which this alias is applied. Used only for aliases which select custom tables."
            },
            "subQuery": {
              "type": "string",
              "description": "If this alias is for sub query."
            }
          },
          "required": ["type", "name"]
        },
        "SelectQuery": {
          "type": "object",
          "properties": {
            "selection": {
              "type": "string"
            },
            "aliasName": {
              "type": "string"
            },
            "virtual": {
              "type": "boolean"
            }
          },
          "required": ["selection"]
        },
        "JoinAttribute": {
          "type": "object",
          "properties": {
            "direction": {
              "type": "string",
              "enum": ["LEFT", "INNER"],
              "description": "Join direction."
            },
            "alias": {
              "$ref": "#/components/schemas/Alias",
              "description": "Alias of the joined (destination) table."
            },
            "entityOrProperty": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Joined table, entity target, or relation in \"post.category\" format."
            },
            "condition": {
              "type": "string",
              "description": "Extra condition applied to \"ON\" section of join."
            },
            "mapToProperty": {
              "type": "string",
              "description": "Property + alias of the object where to joined data should be mapped."
            },
            "isMappingMany": {
              "type": "boolean",
              "description": "Indicates if user maps one or many objects from the join."
            },
            "mapAsEntity": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Useful when the joined expression is a custom query to support mapping."
            },
            "isSelectedCache": {
              "type": "boolean"
            },
            "isSelectedEvaluated": {
              "type": "boolean"
            },
            "relationCache": {
              "$ref": "#/components/schemas/RelationMetadata"
            },
            "relationEvaluated": {
              "type": "boolean"
            }
          },
          "required": ["direction", "alias", "entityOrProperty", "isSelectedCache", "isSelectedEvaluated", "relationEvaluated"],
          "description": "Stores all join attributes which will be used to build a JOIN query."
        },
        "RelationIdAttribute": {
          "type": "object",
          "properties": {
            "alias": {
              "type": "string",
              "description": "Alias of the joined (destination) table."
            },
            "relationName": {
              "type": "string",
              "description": "Name of relation."
            },
            "mapToProperty": {
              "type": "string",
              "description": "Property + alias of the object where to joined data should be mapped."
            },
            "queryBuilderFactory": {
              "$comment": "(qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "qb": {
                      "$ref": "#/components/schemas/SelectQueryBuilder<any>"
                    }
                  },
                  "required": ["qb"],
                  "additionalProperties": false
                }
              },
              "description": "Extra condition applied to \"ON\" section of join."
            },
            "disableMixedMap": {
              "type": "boolean",
              "description": "Indicates if relation id should NOT be loaded as id map."
            }
          },
          "required": ["relationName", "mapToProperty", "disableMixedMap"],
          "description": "Stores all join relation id attributes which will be used to build a JOIN query."
        },
        "RelationCountAttribute": {
          "type": "object",
          "properties": {
            "alias": {
              "type": "string",
              "description": "Alias of the joined (destination) table."
            },
            "relationName": {
              "type": "string",
              "description": "Name of relation."
            },
            "mapToProperty": {
              "type": "string",
              "description": "Property + alias of the object where to joined data should be mapped."
            },
            "queryBuilderFactory": {
              "$comment": "(qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "qb": {
                      "$ref": "#/components/schemas/SelectQueryBuilder<any>"
                    }
                  },
                  "required": ["qb"],
                  "additionalProperties": false
                }
              },
              "description": "Extra condition applied to \"ON\" section of join."
            }
          },
          "required": ["relationName", "mapToProperty"]
        },
        "WhereClause": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": ["simple", "and", "or"]
            },
            "condition": {
              "$ref": "#/components/schemas/WhereClauseCondition"
            }
          },
          "required": ["type", "condition"]
        },
        "WhereClauseCondition": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/components/schemas/WherePredicateOperator"
            },
            {
              "$ref": "#/components/schemas/WhereWrappingOperator"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/WhereClause"
              }
            }
          ]
        },
        "WherePredicateOperator": {
          "type": "object",
          "properties": {
            "operator": {
              "type": "string",
              "enum": [
                "lessThan",
                "lessThanOrEqual",
                "moreThan",
                "moreThanOrEqual",
                "equal",
                "notEqual",
                "ilike",
                "like",
                "between",
                "in",
                "any",
                "isNull",
                "arrayContains",
                "arrayContainedBy",
                "arrayOverlap",
                "and",
                "jsonContains",
                "or"
              ]
            },
            "parameters": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": ["operator", "parameters"]
        },
        "WhereWrappingOperator": {
          "type": "object",
          "properties": {
            "operator": {
              "type": "string",
              "enum": ["not", "brackets"]
            },
            "condition": {
              "$ref": "#/components/schemas/WhereClauseCondition"
            }
          },
          "required": ["operator", "condition"]
        },
        "SelectQueryBuilderOption": {
          "type": "string",
          "enum": ["disable-global-order", "create-pojo"]
        },
        "QueryBuilder<any>": {
          "type": "object",
          "properties": {
            "@instanceof": {},
            "connection": {
              "$ref": "#/components/schemas/DataSource",
              "description": "Connection on which QueryBuilder was created."
            },
            "expressionMap": {
              "$ref": "#/components/schemas/QueryExpressionMap",
              "description": "Contains all properties of the QueryBuilder that needs to be build a final query."
            }
          },
          "required": ["@instanceof", "connection", "expressionMap"],
          "description": "Allows to build complex sql queries in a fashion way and execute those queries."
        },
        "QueryBuilderCteOptions": {
          "type": "object",
          "properties": {
            "materialized": {
              "type": "boolean",
              "description": "Supported only by Postgres currently Oracle users should use query with undocumented materialize hint"
            },
            "recursive": {
              "type": "boolean",
              "description": "Supported by Postgres, SQLite, MySQL and MariaDB SQL Server automatically detects recursive queries"
            },
            "columnNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Overwrite column names If number of columns returned doesn't work, it throws"
            }
          }
        },
        "RelationCountMetadata": {
          "type": "object",
          "properties": {
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata where this column metadata is."
            },
            "relation": {
              "$ref": "#/components/schemas/RelationMetadata",
              "description": "Relation which needs to be counted."
            },
            "relationNameOrFactory": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$comment": "(object: any) => any",
                  "type": "object",
                  "properties": {
                    "namedArgs": {
                      "type": "object",
                      "properties": {
                        "object": {}
                      },
                      "required": ["object"],
                      "additionalProperties": false
                    }
                  }
                }
              ],
              "description": "Relation name which need to count."
            },
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Target class to which metadata is applied."
            },
            "propertyName": {
              "type": "string",
              "description": "Target's property name to which this metadata is applied."
            },
            "alias": {
              "type": "string",
              "description": "Alias of the joined (destination) table."
            },
            "queryBuilderFactory": {
              "$comment": "(qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>",
              "type": "object",
              "properties": {
                "namedArgs": {
                  "type": "object",
                  "properties": {
                    "qb": {
                      "$ref": "#/components/schemas/SelectQueryBuilder<any>"
                    }
                  },
                  "required": ["qb"],
                  "additionalProperties": false
                }
              },
              "description": "Extra condition applied to \"ON\" section of join."
            }
          },
          "required": ["entityMetadata", "relation", "relationNameOrFactory", "target", "propertyName"],
          "description": "Contains all information about entity's relation count."
        },
        "CheckMetadata": {
          "type": "object",
          "properties": {
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata of the class to which this check constraint is applied."
            },
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Target class to which metadata is applied."
            },
            "expression": {
              "type": "string",
              "description": "Check expression."
            },
            "givenName": {
              "type": "string",
              "description": "User specified check constraint name."
            },
            "name": {
              "type": "string",
              "description": "Final check constraint name. If check constraint name was given by a user then it stores normalized (by naming strategy) givenName. If check constraint name was not given then its generated."
            }
          },
          "required": ["entityMetadata", "expression", "name"],
          "description": "Check metadata contains all information about table's check constraints."
        },
        "ExclusionMetadata": {
          "type": "object",
          "properties": {
            "entityMetadata": {
              "$ref": "#/components/schemas/EntityMetadata",
              "description": "Entity metadata of the class to which this exclusion constraint is applied."
            },
            "target": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "prototype": {},
                    "length": {
                      "type": "number"
                    },
                    "arguments": {},
                    "caller": {
                      "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                    }
                  },
                  "required": ["prototype", "length", "arguments", "caller"]
                },
                {
                  "type": "string"
                }
              ],
              "description": "Target class to which metadata is applied."
            },
            "expression": {
              "type": "string",
              "description": "Exclusion expression."
            },
            "givenName": {
              "type": "string",
              "description": "User specified exclusion constraint name."
            },
            "name": {
              "type": "string",
              "description": "Final exclusion constraint name. If exclusion constraint name was given by a user then it stores normalized (by naming strategy) givenName. If exclusion constraint name was not given then its generated."
            }
          },
          "required": ["entityMetadata", "expression", "name"],
          "description": "Exclusion metadata contains all information about table's exclusion constraints."
        },
        "QueryResultCache": {
          "type": "object",
          "description": "Implementations of this interface provide different strategies to cache query builder results."
        },
        "RelationLoader": {
          "type": "object",
          "description": "Wraps entities and creates getters/setters for their relations to be able to lazily load relations when accessing these relations."
        },
        "RelationIdLoader": {
          "type": "object",
          "description": "Loads relation ids for the given entities."
        },
        "StatusListOpts": {
          "type": "object",
          "properties": {
            "statusListId": {
              "type": "string"
            },
            "statusListCorrelationId": {
              "type": "string"
            },
            "statusListIndex": {
              "type": "number"
            },
            "statusEntryCorrelationId": {
              "type": "string"
            }
          }
        },
        "VerifiableCredentialSP": {
          "type": "object",
          "properties": {
            "issuer": {
              "$ref": "#/components/schemas/IssuerType"
            },
            "credentialSubject": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CredentialSubject"
                  }
                },
                {
                  "$ref": "#/components/schemas/CredentialSubject"
                }
              ]
            },
            "type": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "string"
                }
              ]
            },
            "@context": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "string"
                }
              ]
            },
            "issuanceDate": {
              "type": "string"
            },
            "expirationDate": {
              "type": "string"
            },
            "credentialStatus": {
              "$ref": "#/components/schemas/CredentialStatusSP"
            },
            "id": {
              "type": "string"
            },
            "validFrom": {
              "type": "string"
            },
            "validUntil": {
              "type": "string"
            },
            "proof": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/CredentialProofSP"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CredentialProofSP"
                  }
                },
                {
                  "$ref": "#/components/schemas/ProofType"
                }
              ]
            }
          },
          "required": ["@context", "credentialSubject", "issuanceDate", "issuer", "proof"]
        },
        "CredentialStatusSP": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            },
            "type": {
              "type": "string"
            },
            "revocationListIndex": {
              "type": "string"
            },
            "revocationListCredential": {
              "type": "string"
            }
          },
          "required": ["id", "type"]
        },
        "CredentialProofSP": {
          "type": "object",
          "properties": {
            "type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/components/schemas/IProofType"
                }
              ]
            },
            "created": {
              "type": "string"
            },
            "proofPurpose": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IProofPurpose"
                },
                {
                  "type": "string"
                }
              ]
            },
            "verificationMethod": {
              "type": "string"
            },
            "challenge": {
              "type": "string"
            },
            "domain": {
              "type": "string"
            },
            "proofValue": {
              "type": "string"
            },
            "jws": {
              "type": "string"
            },
            "nonce": {
              "type": "string"
            },
            "requiredRevealStatements": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": ["type", "created", "proofPurpose", "verificationMethod"],
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "not": {}
              }
            ]
          }
        },
        "IProofType": {
          "type": "string",
          "enum": [
            "Ed25519Signature2018",
            "Ed25519Signature2020",
            "EcdsaSecp256k1Signature2019",
            "EcdsaSecp256k1RecoverySignature2020",
            "JsonWebSignature2020",
            "RsaSignature2018",
            "GpgSignature2020",
            "JcsEd25519Signature2020",
            "BbsBlsSignatureProof2020",
            "BbsBlsBoundSignatureProof2020",
            "JwtProof2020",
            "SdJwtProof2024",
            "MsoMdocProof2024"
          ]
        },
        "ProofType": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string"
            }
          },
          "description": "A proof property of a  {@link  VerifiableCredential }  or  {@link  VerifiablePresentation }"
        },
        "ICreateVerifiablePresentationLDArgs": {
          "type": "object",
          "properties": {
            "presentation": {
              "$ref": "#/components/schemas/PresentationPayload",
              "description": "The json payload of the Presentation according to the  {@link https://www.w3.org/TR/vc-data-model/#presentations | canonical model } .\n\nThe signer of the Presentation is chosen based on the `holderDID` property of the `presentation`\n\n'@context', 'type' and 'issuanceDate' will be added automatically if omitted"
            },
            "challenge": {
              "type": "string",
              "description": "Optional (only JWT) string challenge parameter to add to the verifiable presentation."
            },
            "domain": {
              "type": "string",
              "description": "Optional string domain parameter to add to the verifiable presentation."
            },
            "keyRef": {
              "type": "string",
              "description": "Optional. The key handle ( {@link  IKey#kid  } ) from the internal database."
            },
            "purpose": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IAuthenticationProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IControllerProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IAssertionProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IProofPurpose"
                }
              ]
            }
          },
          "required": ["presentation"],
          "description": "Encapsulates the parameters required to create a  {@link https://www.w3.org/TR/vc-data-model/#presentations | W3C Verifiable Presentation }"
        },
        "PresentationPayload": {
          "type": "object",
          "properties": {
            "holder": {
              "type": "string"
            },
            "verifiableCredential": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/W3CVerifiableCredential"
              }
            },
            "type": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "@context": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "verifier": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "issuanceDate": {
              "$ref": "#/components/schemas/DateType"
            },
            "expirationDate": {
              "$ref": "#/components/schemas/DateType"
            },
            "id": {
              "type": "string"
            }
          },
          "required": ["holder"],
          "description": "Used as input when creating Verifiable Presentations"
        },
        "W3CVerifiableCredential": {
          "anyOf": [
            {
              "$ref": "#/components/schemas/IVerifiableCredential"
            },
            {
              "$ref": "#/components/schemas/CompactJWT"
            }
          ],
          "description": "Represents a signed Verifiable Credential (includes proof), in either JSON, compact JWT or compact SD-JWT VC format. See  {@link https://www.w3.org/TR/vc-data-model/#credentials | VC data model }  See  {@link https://www.w3.org/TR/vc-data-model/#proof-formats | proof formats }"
        },
        "VerifiableCredential": {
          "type": "object",
          "properties": {
            "proof": {
              "$ref": "#/components/schemas/ProofType"
            },
            "issuer": {
              "$ref": "#/components/schemas/IssuerType"
            },
            "credentialSubject": {
              "$ref": "#/components/schemas/CredentialSubject"
            },
            "type": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "string"
                }
              ]
            },
            "@context": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "string"
                }
              ]
            },
            "issuanceDate": {
              "type": "string"
            },
            "expirationDate": {
              "type": "string"
            },
            "credentialStatus": {
              "$ref": "#/components/schemas/CredentialStatusReference"
            },
            "id": {
              "type": "string"
            }
          },
          "required": ["@context", "credentialSubject", "issuanceDate", "issuer", "proof"],
          "description": "Represents a signed Verifiable Credential payload (includes proof), using a JSON representation. See  {@link https://www.w3.org/TR/vc-data-model/#credentials | VC data model }"
        },
        "CompactJWT": {
          "type": "string",
          "description": "Represents a Json Web Token in compact form."
        },
        "VerifiablePresentationSP": {
          "type": "object",
          "properties": {
            "holder": {
              "type": "string"
            },
            "verifiableCredential": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/W3CVerifiableCredentialSP"
              }
            },
            "type": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "string"
                }
              ]
            },
            "@context": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "string"
                }
              ]
            },
            "verifier": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "issuanceDate": {
              "type": "string"
            },
            "expirationDate": {
              "type": "string"
            },
            "id": {
              "type": "string"
            },
            "presentation_submission": {
              "$ref": "#/components/schemas/PresentationSubmission"
            },
            "proof": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/CredentialProofSP"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CredentialProofSP"
                  }
                },
                {
                  "$ref": "#/components/schemas/ProofType"
                }
              ]
            }
          },
          "required": ["@context", "holder", "proof", "type", "verifiableCredential"]
        },
        "W3CVerifiableCredentialSP": {
          "anyOf": [
            {
              "$ref": "#/components/schemas/VerifiableCredential"
            },
            {
              "$ref": "#/components/schemas/VerifiableCredentialSP"
            },
            {
              "$ref": "#/components/schemas/CompactJWT"
            }
          ]
        },
        "PresentationSubmission": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "A UUID or some other unique ID to identify this Presentation Submission"
            },
            "definition_id": {
              "type": "string",
              "description": "A UUID or some other unique ID to identify this Presentation Definition"
            },
            "descriptor_map": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Descriptor"
              },
              "description": "List of descriptors of how the claims are being mapped to presentation definition"
            }
          },
          "required": ["id", "definition_id", "descriptor_map"],
          "description": "It expresses how the inputs are presented as proofs to a Verifier."
        },
        "Descriptor": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID to identify the descriptor from Presentation Definition Input Descriptor it coresponds to."
            },
            "path": {
              "type": "string",
              "description": "The path where the verifiable credential is located in the presentation submission json"
            },
            "path_nested": {
              "$ref": "#/components/schemas/Descriptor"
            },
            "format": {
              "type": "string",
              "description": "The Proof or JWT algorith that the proof is in"
            }
          },
          "required": ["id", "path", "format"],
          "description": "descriptor map laying out the structure of the presentation submission."
        },
        "IVerifyCredentialLDArgs": {
          "type": "object",
          "properties": {
            "credential": {
              "$ref": "#/components/schemas/VerifiableCredential",
              "description": "The json payload of the Credential according to the  {@link https://www.w3.org/TR/vc-data-model/#credentials | canonical model } \n\nThe signer of the Credential is chosen based on the `issuer.id` property of the `credential`"
            },
            "fetchRemoteContexts": {
              "type": "boolean",
              "description": "Set this to true if you want the '@context' URLs to be fetched in case they are not pre-loaded.",
              "default": false
            },
            "purpose": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IAuthenticationProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IControllerProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IAssertionProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IProofPurpose"
                }
              ],
              "description": "Use this presentation purpose for the verification method in the DID when doing a check (defaults to CredentialIssuancePurpose)"
            },
            "checkStatus": {
              "type": "object",
              "properties": {
                "prototype": {},
                "length": {
                  "type": "number"
                },
                "arguments": {},
                "caller": {
                  "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                }
              },
              "required": ["prototype", "length", "arguments", "caller"],
              "description": "Check status function, to check verifiableCredentials that have a credentialStatus property"
            },
            "statusList": {
              "$ref": "#/components/schemas/StatusListCheck",
              "description": "Allows you to use the default integrated statusList 2021 support. If a checkStatus function is provided, this will be ignored"
            }
          },
          "required": ["credential"],
          "description": "Encapsulates the parameters required to verify a  {@link https://www.w3.org/TR/vc-data-model/#credentials | W3C Verifiable Credential }"
        },
        "StatusListCheck": {
          "type": "object",
          "properties": {
            "disableCheckStatusList2021": {
              "type": "boolean",
              "description": "If no checkStatus function is given we default to a StatusList2021 check in case the VC has a credentialStatus. This boolean allows to disable this fallback check"
            },
            "mandatoryCredentialStatus": {
              "type": "boolean"
            },
            "verifyStatusListCredential": {
              "type": "boolean"
            },
            "verifyMatchingIssuers": {
              "type": "boolean"
            },
            "errorUnknownListType": {
              "type": "boolean"
            }
          },
          "required": ["mandatoryCredentialStatus", "verifyStatusListCredential", "verifyMatchingIssuers"]
        },
        "IVerifyResult": {
          "type": "object",
          "properties": {
            "verified": {
              "type": "boolean",
              "description": "This value is used to transmit the global result of verification."
            },
            "results": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "credential": {
                    "$ref": "#/components/schemas/ICredential"
                  },
                  "presentation": {
                    "$ref": "#/components/schemas/IPresentation"
                  },
                  "verified": {
                    "type": "boolean"
                  },
                  "error": {
                    "$ref": "#/components/schemas/IError"
                  },
                  "log": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "id": {
                          "type": "string"
                        },
                        "valid": {
                          "type": "boolean"
                        }
                      },
                      "required": ["id", "valid"]
                    },
                    "minItems": 1,
                    "maxItems": 1
                  }
                },
                "required": ["verified", "log"]
              },
              "minItems": 1,
              "maxItems": 1
            },
            "statusResult": {
              "$ref": "#/components/schemas/IVerifyStatusResult"
            },
            "error": {
              "$ref": "#/components/schemas/IError",
              "description": "Optional Error object for the but currently the machine readable errors are not exported from DID-JWT package to be imported here"
            }
          },
          "required": ["verified"],
          "additionalProperties": {
            "description": "Other options can be specified for verification. They will be forwarded to the lower level modules. that performt the checks"
          }
        },
        "ICredential": {
          "type": "object",
          "properties": {
            "@context": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ICredentialContextType"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ICredentialContextType"
                  }
                }
              ]
            },
            "type": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "credentialSchema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ICredentialSchemaType"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ICredentialSchemaType"
                  }
                }
              ]
            },
            "issuer": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IIssuerId"
                },
                {
                  "$ref": "#/components/schemas/IIssuer"
                }
              ]
            },
            "issuanceDate": {
              "type": "string"
            },
            "credentialSubject": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string"
                    }
                  }
                },
                {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    }
                  }
                }
              ]
            },
            "expirationDate": {
              "type": "string"
            },
            "id": {
              "type": "string"
            },
            "credentialStatus": {
              "$ref": "#/components/schemas/ICredentialStatus"
            },
            "description": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": ["@context", "type", "issuer", "issuanceDate", "credentialSubject"]
        },
        "ICredentialContextType": {
          "anyOf": [
            {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string"
                },
                "did": {
                  "type": "string"
                }
              }
            },
            {
              "type": "string"
            }
          ]
        },
        "ICredentialSchemaType": {
          "anyOf": [
            {
              "$ref": "#/components/schemas/ICredentialSchema"
            },
            {
              "type": "string"
            }
          ]
        },
        "ICredentialSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            },
            "type": {
              "type": "string"
            }
          },
          "required": ["id"]
        },
        "IIssuerId": {
          "type": "string"
        },
        "IIssuer": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            }
          },
          "required": ["id"]
        },
        "ICredentialStatus": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            },
            "type": {
              "type": "string"
            }
          },
          "required": ["id", "type"]
        },
        "IPresentation": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            },
            "@context": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ICredentialContextType"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ICredentialContextType"
                  }
                }
              ]
            },
            "type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "verifiableCredential": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/W3CVerifiableCredential"
              }
            },
            "presentation_submission": {
              "$ref": "#/components/schemas/PresentationSubmission"
            },
            "holder": {
              "type": "string"
            },
            "verifier": {
              "type": "string"
            }
          },
          "required": ["@context"]
        },
        "IVerifiableCredential": {
          "type": "object",
          "properties": {
            "proof": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IProof"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IProof"
                  }
                }
              ]
            },
            "@context": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ICredentialContextType"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ICredentialContextType"
                  }
                }
              ]
            },
            "type": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "credentialSchema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ICredentialSchemaType"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ICredentialSchemaType"
                  }
                }
              ]
            },
            "issuer": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IIssuerId"
                },
                {
                  "$ref": "#/components/schemas/IIssuer"
                }
              ]
            },
            "issuanceDate": {
              "type": "string"
            },
            "credentialSubject": {
              "anyOf": [
                {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string"
                    }
                  }
                },
                {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    }
                  }
                }
              ]
            },
            "expirationDate": {
              "type": "string"
            },
            "id": {
              "type": "string"
            },
            "credentialStatus": {
              "$ref": "#/components/schemas/ICredentialStatus"
            },
            "description": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": ["@context", "credentialSubject", "issuanceDate", "issuer", "proof", "type"]
        },
        "IProof": {
          "type": "object",
          "properties": {
            "type": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IProofType"
                },
                {
                  "type": "string"
                }
              ]
            },
            "created": {
              "type": "string"
            },
            "proofPurpose": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IProofPurpose"
                },
                {
                  "type": "string"
                }
              ]
            },
            "verificationMethod": {
              "type": "string"
            },
            "challenge": {
              "type": "string"
            },
            "domain": {
              "type": "string"
            },
            "proofValue": {
              "type": "string"
            },
            "jws": {
              "type": "string"
            },
            "jwt": {
              "type": "string"
            },
            "mso_mdoc": {
              "type": "string"
            },
            "nonce": {
              "type": "string"
            },
            "requiredRevealStatements": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": ["type", "created", "proofPurpose", "verificationMethod"]
        },
        "IError": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "errors": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IError"
              }
            },
            "message": {
              "type": "string",
              "description": "The details of the error being thrown or forwarded"
            },
            "stack": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "The stack of the error"
            },
            "details": {
              "$ref": "#/components/schemas/IErrorDetails"
            },
            "errorCode": {
              "type": "string",
              "description": "The code for the error being throw"
            }
          },
          "description": "An error object, which can contain a code."
        },
        "IErrorDetails": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string"
            },
            "url": {
              "type": "string"
            },
            "cause": {
              "$ref": "#/components/schemas/IError"
            }
          }
        },
        "IVerifyStatusResult": {
          "type": "object",
          "properties": {
            "verified": {
              "type": "boolean"
            },
            "error": {
              "$ref": "#/components/schemas/IError",
              "description": "Optional Error object for the but currently the machine readable errors are not exported from DID-JWT package to be imported here"
            }
          },
          "required": ["verified"],
          "additionalProperties": {
            "description": "Other options can be specified for verification. They will be forwarded to the lower level modules. that performt the checks"
          }
        },
        "IVerifyPresentationLDArgs": {
          "type": "object",
          "properties": {
            "presentation": {
              "$ref": "#/components/schemas/VerifiablePresentation",
              "description": "The json payload of the Credential according to the  {@link https://www.w3.org/TR/vc-data-model/#credentials | canonical model } \n\nThe signer of the Credential is chosen based on the `issuer.id` property of the `credential`"
            },
            "challenge": {
              "type": "string",
              "description": "Optional (only for JWT) string challenge parameter to verify the verifiable presentation against"
            },
            "domain": {
              "type": "string",
              "description": "Optional (only for JWT) string domain parameter to verify the verifiable presentation against"
            },
            "fetchRemoteContexts": {
              "type": "boolean",
              "description": "Set this to true if you want the '@context' URLs to be fetched in case they are not pre-loaded.",
              "default": false
            },
            "presentationPurpose": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IAuthenticationProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IControllerProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IAssertionProofPurpose"
                },
                {
                  "$ref": "#/components/schemas/IProofPurpose"
                }
              ],
              "description": "Use this presentation purpose for the verification method in the DID when doing a check (defaualts to assertionMethod)"
            },
            "checkStatus": {
              "type": "object",
              "properties": {
                "prototype": {},
                "length": {
                  "type": "number"
                },
                "arguments": {},
                "caller": {
                  "$ref": "#/components/schemas/interface-1506616821-9888-11315-1506616821-0-215038"
                }
              },
              "required": ["prototype", "length", "arguments", "caller"],
              "description": "Check status function, to check verifiableCredentials that have a credentialStatus property"
            },
            "statusList": {
              "$ref": "#/components/schemas/StatusListCheck",
              "description": "Allows you to use the default integrated statusList 2021 support. If a checkStatus function is provided, this will be ignored"
            }
          },
          "required": ["presentation"],
          "description": "Encapsulates the parameters required to verify a  {@link https://www.w3.org/TR/vc-data-model/#presentations | W3C Verifiable Presentation }"
        },
        "VerifiablePresentation": {
          "type": "object",
          "properties": {
            "proof": {
              "$ref": "#/components/schemas/ProofType"
            },
            "holder": {
              "type": "string"
            },
            "verifiableCredential": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/W3CVerifiableCredential"
              }
            },
            "type": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "string"
                }
              ]
            },
            "@context": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "string"
                }
              ]
            },
            "verifier": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "issuanceDate": {
              "type": "string"
            },
            "expirationDate": {
              "type": "string"
            },
            "id": {
              "type": "string"
            }
          },
          "required": ["@context", "holder", "proof"],
          "description": "Represents a signed Verifiable Presentation (includes proof), using a JSON representation. See  {@link https://www.w3.org/TR/vc-data-model/#presentations | VP data model }"
        }
      },
      "methods": {
        "createVerifiableCredentialLDLocal": {
          "description": "Creates a Verifiable Credential. The payload, signer and format are chosen based on the ",
          "arguments": {
            "$ref": "#/components/schemas/ICreateVerifiableCredentialLDArgs"
          },
          "returnType": {
            "$ref": "#/components/schemas/VerifiableCredentialSP"
          }
        },
        "createVerifiablePresentationLDLocal": {
          "description": "Creates a Verifiable Presentation. The payload, signer and format are chosen based on the ",
          "arguments": {
            "$ref": "#/components/schemas/ICreateVerifiablePresentationLDArgs"
          },
          "returnType": {
            "$ref": "#/components/schemas/VerifiablePresentationSP"
          }
        },
        "verifyCredentialLDLocal": {
          "description": "Verifies a Verifiable Credential JWT or LDS Format.",
          "arguments": {
            "$ref": "#/components/schemas/IVerifyCredentialLDArgs"
          },
          "returnType": {
            "$ref": "#/components/schemas/IVerifyResult"
          }
        },
        "verifyPresentationLDLocal": {
          "description": "Verifies a Verifiable Presentation JWT or LDS Format.",
          "arguments": {
            "$ref": "#/components/schemas/IVerifyPresentationLDArgs"
          },
          "returnType": {
            "$ref": "#/components/schemas/IVerifyResult"
          }
        }
      }
    }
  }
}
